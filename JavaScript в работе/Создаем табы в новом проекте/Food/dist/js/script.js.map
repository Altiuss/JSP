{"version":3,"file":"script.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA,yBAAyB;AACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHwB;AAC6H;AAC/G;AACI;AAClB;AACY;;;;;;;;;;;;;;;;;;;;;;;;;ACLyF;AAC7C;AACzE;AACP;AACA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA,WAAW,qDAAa;AACxB,IAAI;AACJ;AACA;AACA;AACA,iBAAiB,qDAAa,CAAC,uEAAQ;AACvC;;AAEA;AACA;AACA,iBAAiB,qDAAa,CAAC,uEAAQ;AACvC;;AAEA;AACA;AACA,iBAAiB,yDAAiB,CAAC,uEAAQ;AAC3C;;AAEA;AACA;AACA,iBAAiB,oDAAY,CAAC,uEAAQ,YAAY,2EAAY,YAAY,2EAAY;AACtF;AACA;;AAEA;AACA;AACA,iBAAiB,oDAAY,CAAC,uEAAQ,YAAY,2EAAY,YAAY,2EAAY;AACtF;AACA;AACA;AACA;AACO;AACP;AACA;AACA,SAAS,6CAAK;AACd;AACO;AACP;AACA;AACA,SAAS,6CAAK;AACd;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnFA,2CAA2C,gCAAgC,oCAAoC,oDAAoD,sBAAsB,0CAA0C,iEAAiE,KAAK,kCAAkC;;AAE3U,iCAAiC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,4CAA4C,KAAK,6CAA6C,6EAA6E,OAAO,iDAAiD,mFAAmF,OAAO;;AAEtgB,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0GAA0G,CAAS;AACnH;;AAEA;AACA,uFAAuF,CAAS;AAChG;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uFAAuF,CAAS;AAChG;;AAEA;AACA,oCAAoC;;AAEpC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP,6BAA6B,YAAY;;;AAGzC,mDAAmD;;AAEnD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5IA,wBAAwB,2BAA2B,2EAA2E,kCAAkC,wBAAwB,OAAO,kCAAkC,mIAAmI;;AAEpW;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uDAAuD,MAAS;AAChE;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA,8HAA8H,CAAS;AACvI;AACA;;AAEA;AACA,yGAAyG,MAAS;AAClH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,6GAA6G,MAAS;AACtH;;AAEA;AACA;AACA,yHAAyH,MAAS;AAClI;AACA;;AAEA;AACA;AACA,mHAAmH,MAAS;AAC5H;AACA;;AAEA;AACA;AACA,iHAAiH,MAAS;AAC1H;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA,oJAAoJ,CAAS;AAC7J;;AAEA;AACA,6JAA6J,CAAS;AACtK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8HAA8H,CAAS;AACvI;AACA;;AAEA;AACA,qGAAqG,MAAS;AAC9G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8HAA8H,CAAS;AACvI;AACA;;AAEA;AACA,yGAAyG,MAAS;AAClH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uJAAuJ,CAAS;AAChK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+GAA+G,MAAS;AACxH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,6GAA6G,MAAS;AACtH;;AAEA;AACA,mHAAmH,MAAS;AAC5H;;AAEA;AACA,mGAAmG,MAAS;AAC5G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kIAAkI,CAAS;AAC3I;;AAEA;AACA,2IAA2I,CAAS;AACpJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uGAAuG,MAAS;AAChH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4HAA4H,CAAS;AACrI;;AAEA;AACA,qGAAqG,MAAS;AAC9G;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,qGAAqG,MAAS;AAC9G;;AAEA;AACA,iHAAiH,MAAS;AAC1H;;AAEA;AACA,+GAA+G,MAAS;AACxH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA,+HAA+H,CAAS;AACxI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+HAA+H,CAAS;AACxI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA;AACA,mIAAmI,CAAS;AAC5I;AACA;;AAEA;AACA;AACA,mIAAmI,CAAS;AAC5I;AACA;;AAEA;AACA,+HAA+H,CAAS;AACxI;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,yGAAyG,MAAS;AAClH;;AAEA;AACA,uGAAuG,MAAS;AAChH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qGAAqG,MAAS;AAC9G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gIAAgI,CAAS;AACzI;;AAEA;AACA;AACA,+GAA+G,MAAS;AACxH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wIAAwI,CAAS;AACjJ;;AAEA;AACA,kIAAkI,CAAS;AAC3I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kIAAkI,CAAS;AAC3I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+HAA+H,CAAS;AACxI;;AAEA;AACA;AACA,iIAAiI,CAAS;AAC1I;AACA;;AAEA;AACA;AACA,4IAA4I,CAAS;AACrJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,yGAAyG,MAAS;AAClH;;AAEA;AACA,2GAA2G,MAAS;AACpH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qGAAqG,MAAS;AAC9G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qIAAqI,CAAS;AAC9I;;AAEA;AACA;AACA,iIAAiI,CAAS;AAC1I;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,uGAAuG,MAAS;AAChH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iHAAiH,MAAS;AAC1H;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA,yGAAyG,MAAS;AAClH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,yGAAyG,MAAS;AAClH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qGAAqG,MAAS;AAC9G;;AAEA;AACA;AACA,wJAAwJ,CAAS;AACjK;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,wIAAwI,CAAS;AACjJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wIAAwI,CAAS;AACjJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wIAAwI,CAAS;AACjJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;AC55BP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;;;;;;;;;;;;;;;;;ACtMxC,kDAAkD,0CAA0C;;AAE5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;;AAE/P,8DAA8D,sEAAsE,8DAA8D;;AAEpI;AACvD;AACP;;AAEA;AACA,0DAA0D,MAAS;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,sDAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR,aAAa,0DAAe;AAC5B,kFAAkF,MAAS;AAC3F;;AAEA;;AAEA;AACA,iEAAiE,MAAS;AAC1E;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mEAAmE,MAAS;AAC5E;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA,6EAA6E,MAAS;AACtF;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mEAAmE,MAAS;AAC5E;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;;;;;;;;;;;;;;;;ACxXwC;AACkB,CAAC;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,sDAAU;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEO;AACP;AACA;AACA;AACA,SAAS,qDAAiB;AAC1B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iDAAa;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FA,kCAAkC;;AAElC,8BAA8B;;AAE9B,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;;AAE7S,uCAAuC,uDAAuD,uCAAuC,SAAS,OAAO,oBAAoB;;AAEzK,yCAAyC,0GAA0G,wBAAwB,eAAe,eAAe,gBAAgB,YAAY,MAAM,wBAAwB,+BAA+B,aAAa,qBAAqB,uCAAuC,cAAc,WAAW,YAAY,UAAU,MAAM,mDAAmD,UAAU,sBAAsB;;AAEnf,gCAAgC;;AAEhC,wBAAwB,2BAA2B,2EAA2E,kCAAkC,wBAAwB,OAAO,kCAAkC,mIAAmI;;AAE1T;AACJ;AACsB;AACY;AACjE;AACP;AACA;AACO;AACP;AACA,EAAE,mDAAQ;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACO;AACP;AACA,EAAE,mDAAQ;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,cAAc,2EAAS;AACvB,cAAc,2EAAS;;AAEvB;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG,OAAO;;AAEV;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,kCAAkC;;AAElC;AACA;AACO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA,kCAAkC;;AAElC,EAAE,mDAAQ;AACV;AACA;AACA,oBAAoB,sFAAiB;;AAErC;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;;AAEA;AACA;AACA;;AAEA,aAAa,mDAAU;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,wDAAwD,MAAS;AACjE;;AAEA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA,8EAA8E,MAAS;AACvF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E,MAAS;AACnF;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,8EAA8E,MAAS;AACvF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0EAA0E,MAAS;AACnF;;AAEA;AACA;AACA;;;;;;;;;;;;;;;AC/Qe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;ACzCA,wBAAwB,2BAA2B,2EAA2E,kCAAkC,wBAAwB,OAAO,kCAAkC,mIAAmI;;AAEpW,kDAAkD,0CAA0C;;AAE5F,2CAA2C,+DAA+D,6EAA6E,yEAAyE,eAAe,uDAAuD,GAAG;;AAEzU,iCAAiC,6DAA6D,yCAAyC,8CAA8C,iCAAiC,mDAAmD,2DAA2D,OAAO,yCAAyC;;AAEpX,kDAAkD,0EAA0E,eAAe,4BAA4B,mFAAmF;;AAE1P,wCAAwC,uBAAuB,yFAAyF;;AAExJ,mCAAmC,gEAAgE,sDAAsD,+DAA+D,mCAAmC,6EAA6E,qCAAqC,iDAAiD,8BAA8B,qBAAqB,0EAA0E,qDAAqD,eAAe,yEAAyE,GAAG,2CAA2C;;AAEttB,2CAA2C,mCAAmC,kCAAkC,OAAO,wDAAwD,gBAAgB,uBAAuB,kDAAkD,kCAAkC,uDAAuD,sBAAsB;;AAEvX,uCAAuC,wEAAwE,0CAA0C,8CAA8C,MAAM,4EAA4E,IAAI,eAAe,YAAY;;AAExT,iCAAiC;;AAEjC,iCAAiC,4EAA4E,iBAAiB,aAAa;;AAE3I,8BAA8B,gGAAgG,mDAAmD;;AAE1K;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AACM;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AACM;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;AC9D6B;AACuC;AACN;AACxD;AACP;AACA,WAAW,oFAAa;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA,WAAW,oFAAa;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,oFAAa;AACxB;;AAEA;AACA;AACO;AACP;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACO;AACP;;AAEA;AACA,cAAc,yEAAY;AAC1B;;AAEA;AACA;AACO;AACP;AACA;;AAEA;AACA,YAAY,4DAAe;AAC3B,IAAI;AACJ;AACA,IAAI;AACJ,YAAY,4DAAe;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;AC3FA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,YAAY;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;AC7ZK;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC9B4C;AAC5C;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACA;AACA;AACA;AACP;AACA,EAAE,oDAAK;AACP;AACA;AACO;AACP;AACA,EAAE,oDAAK;AACP;AACA;AACO;AACP;AACA,SAAS,mDAAI;AACb;AACO;AACP;AACA,SAAS,mDAAI;AACb;;;;;;;;;;;;;;;;;;AChCA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,kBAAkB,kCAAkC,iBAAiB;AACrE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,yCAAyC;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AChJA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGO;AACP;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA,IAAI;AACJ,8BAA8B,SAAS;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA,IAAI;AACJ,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnOwB;AACxB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACA;AACP,SAAS,4CAAG;AACZ;AACO;AACP,SAAS,4CAAG;AACZ;AACO;AACP,SAAS,4CAAG;AACZ;AACO;AACP,SAAS,4CAAG;AACZ;AACO;AACP,SAAS,4CAAG;AACZ;AACO;AACP,SAAS,4CAAG;AACZ;AACO;AACP,SAAS,4CAAG;AACZ;;;;;;;;;;;;;;;;;;;ACjCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACa;;AAEiB;AACC;AACA;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,4CAAc,CAAC,0CAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,eAAe,4CAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,cAAc,0CAAY;AAC1B;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,eAAe,wCAAU;;AAEzB,kBAAkB,eAAe;AACjC,kBAAkB,0CAAY;AAC9B;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;;AAEZ,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,eAAe,wCAAU;AACzB;;AAEA;AACA,IAAI,yCAAW;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;;AAE/B;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;;AAEA,WAAW,yCAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0CAAY;AAC3B;AACA,EAAE,uCAAS;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,wCAAU;AACtB,EAAE,6CAAe;AACjB;AACA,EAAE,uCAAS;AACX;AACA;;AAEA;AACA,sDAAsD;;AAEtD;;AAEA;AACA,mBAAmB,yCAAW;AAC9B;AACA;;AAEA,cAAc,6DAAgB;AAC9B,EAAE,uCAAS;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2CAAa;AAC5B;AACA,EAAE,uCAAS;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,wCAAU;AACtB,EAAE,8CAAgB;AAClB;AACA,EAAE,uCAAS;AACX;AACA;;AAEA;AACA;AACA,cAAc,6DAAgB;AAC9B,EAAE,uCAAS;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;ACvUD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AClEA,mCAAmC;;AAEnC,gCAAgC;;AAEhC,mCAAmC;;AAEnC,yBAAyB;;AAEzB,8BAA8B;;AAE9B,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;;AAE7S,uCAAuC,uDAAuD,uCAAuC,SAAS,OAAO,oBAAoB;;AAEzK,kCAAkC;;AAElC,gCAAgC;;AAEhC;AACA;AACA;;AAEO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC3DmC;;;;;;;;;;;;ACAtB;;AAEb,wBAAwB,2BAA2B,2EAA2E,kCAAkC,wBAAwB,OAAO,kCAAkC,mIAAmI;;AAEpW,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc;;AAEd,sBAAsB,mBAAO,CAAC,oGAAiC;;AAE/D,sCAAsC,mBAAO,CAAC,kFAAwB;;AAEtE,mCAAmC,mBAAO,CAAC,4EAAqB;;AAEhE,gCAAgC,mBAAO,CAAC,0EAAoB;;AAE5D,WAAW,mBAAO,CAAC,gFAAuB;;AAE1C,iDAAiD,mBAAO,CAAC,4GAAqC;;AAE9F,uCAAuC,uCAAuC;;AAE9E,iDAAiD,gDAAgD,uCAAuC,sCAAsC,oFAAoF,4DAA4D;;AAE9T,qDAAqD,6CAA6C,cAAc,8EAA8E,SAAS,oBAAoB,mDAAmD,+BAA+B,yBAAyB,iBAAiB,sFAAsF,uBAAuB,2EAA2E,qFAAqF,sCAAsC,4CAA4C,OAAO,8BAA8B,yBAAyB,aAAa,0BAA0B;;AAE3xB,mCAAmC;;AAEnC,gCAAgC;;AAEhC,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;;AAE7S,kCAAkC;;AAElC,mCAAmC;;AAEnC,uCAAuC,uDAAuD,uCAAuC,SAAS,OAAO,oBAAoB;;AAEzK;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA,mDAAmD;AACnD;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;;AAGA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,IAAI;AACJ;;;AAGA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;;;AAGA;AACA,2CAA2C;;AAE3C,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;;;AAGA;AACA,+CAA+C;;AAE/C,oBAAoB,mBAAmB;AACvC;;AAEA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,kBAAkB;AAC5C;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA;AACA,uCAAuC;;AAEvC;;AAEA,4BAA4B,2BAA2B;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;;AAErD;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA,wCAAwC;;AAExC;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;;AAElC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,UAAU;AACV;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;;AAGA;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,yBAAyB,gCAAgC;AACzD;AACA;AACA,qCAAqC;;AAErC;AACA,sCAAsC;;AAEtC,8BAA8B,8BAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,UAAU;;;AAGV;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,gBAAgB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV,QAAQ;AACR;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,iBAAiB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;;AAEA,0BAA0B,aAAa;AACvC;;AAEA;AACA;AACA;AACA,UAAU;;AAEV,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA,UAAU;;AAEV,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,UAAU;;AAEV,QAAQ;AACR;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,UAAU;;AAEV,QAAQ;AACR;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;;;AAGJ;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,sCAAsC;AACtC,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd,0FAA0F;AAC1F;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,cAAc;AACd,+FAA+F;AAC/F;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,QAAQ;AACR,sDAAsD;AACtD,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK,GAAG;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACj7DO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,SAAS,WAAW;;AAEpB;AACA;AACA,SAAS,UAAU;;AAEnB;AACA;;;;;;;;;;;ACnFA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA,sDAAsD,aAAa;;AAEnE;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,wBAAwB;;AAExB;AACA,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,WAAW,sBAAsB,+CAA+C;AAChF,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB,+CAA+C;AAChF,WAAW,UAAU;AACrB,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,SAAS;AACpB,aAAa;AACb;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,gEAAgE,kBAAkB;AAClF,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2EAA2E,kBAAkB;AAC7F;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,iFAAiF,qBAAqB;AACtG;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA,iFAAiF,qBAAqB;AACtG;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,iFAAiF,oBAAoB;AACrG;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,0FAA0F,2BAA2B;AACrH;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA,0FAA0F,2BAA2B;AACrH;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,uBAAuB;AAC3G;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,6FAA6F,8BAA8B;AAC3H;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA,6FAA6F,8BAA8B;AAC3H;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yEAAyE,mBAAmB;AAC5F;AACA,WAAW,qBAAqB;AAChC,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,kBAAkB;AACrE;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,oBAAoB;AACnG;AACA,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4EAA4E,oBAAoB;AAChG;AACA,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mBAAmB;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE,kBAAkB;AACtF;AACA,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gEAAgE,kBAAkB;AAClF;AACA,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,gEAAgE,kBAAkB;AAClF;AACA,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6FAA6F,qBAAqB;AAClH;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6GAA6G,sBAAsB;AACnI;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wGAAwG,8BAA8B;AACtI;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,wGAAwG,8BAA8B;AACtI;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,sBAAsB;AACnH;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,uBAAuB;AACrH;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,UAAU;AACV,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC53CA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACLoF;AAEpFC,QAAQ,CAACC,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;EAEhD,MAAMC,IAAI,GAAGF,QAAQ,CAACG,gBAAgB,CAAC,kBAAkB,CAAC;EAC1D,MAAMC,WAAW,GAAGJ,QAAQ,CAACG,gBAAgB,CAAC,aAAa,CAAC;EAC5D,MAAME,UAAU,GAAGL,QAAQ,CAACM,aAAa,CAAC,mBAAmB,CAAC;EAE9DC,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEN,IAAI,CAAC;EAC1BK,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEJ,WAAW,CAAC;EAMxC,SAASK,cAAcA,CAAA,EAAG;IACtBL,WAAW,CAACM,OAAO,CAACC,IAAI,IAAI;MACxBA,IAAI,CAACC,KAAK,CAACC,OAAO,GAAG,MAAM;IAC/B,CAAC,CAAC;IACFX,IAAI,CAACQ,OAAO,CAACC,IAAI,IAAI;MACjBA,IAAI,CAACG,SAAS,CAACC,MAAM,CAAC,wBAAwB,CAAC;IACnD,CAAC,CAAC;EACN;EAEA,SAASC,cAAcA,CAACC,CAAC,GAAG,CAAC,EAAE;IAC3Bb,WAAW,CAACa,CAAC,CAAC,CAACL,KAAK,CAACC,OAAO,GAAG,OAAO;IAEtCX,IAAI,CAACe,CAAC,CAAC,CAACH,SAAS,CAACI,GAAG,CAAC,wBAAwB,CAAC;EACnD;EAKAb,UAAU,CAACJ,gBAAgB,CAAC,OAAO,EAAGkB,CAAC,IAAK;IACxC,MAAMC,MAAM,GAAGD,CAAC,CAACC,MAAM;IACvB,IAAIA,MAAM,IAAIA,MAAM,CAACN,SAAS,CAACO,QAAQ,CAAC,iBAAiB,CAAC,EAAE;MACxDnB,IAAI,CAACQ,OAAO,CAAC,CAACY,GAAG,EAAEvB,KAAK,KAAK;QACzB,IAAIqB,MAAM,KAAKE,GAAG,EAAE;UAChBb,cAAc,CAAC,CAAC;UAChBO,cAAc,CAACjB,KAAK,CAAC;QACzB;MAEJ,CAAC,CAAC;IACN;EAEJ,CAAC,CAAC;EAEFU,cAAc,CAAC,CAAC;EAEhBO,cAAc,CAAC,CAAC;AA0CpB,CAAC,CAAC,C","sources":["webpack://food/./node_modules/@webassemblyjs/ast/esm/clone.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/index.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/node-helpers.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/node-path.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/nodes.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/signatures.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/transform/ast-module-to-module-context/index.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/traverse.js","webpack://food/./node_modules/@webassemblyjs/ast/esm/utils.js","webpack://food/./node_modules/@webassemblyjs/floating-point-hex-parser/esm/index.js","webpack://food/./node_modules/@webassemblyjs/helper-api-error/esm/index.js","webpack://food/./node_modules/@webassemblyjs/helper-numbers/esm/index.js","webpack://food/./node_modules/@webassemblyjs/helper-wasm-bytecode/esm/index.js","webpack://food/./node_modules/@webassemblyjs/helper-wasm-bytecode/esm/section.js","webpack://food/./node_modules/@webassemblyjs/ieee754/esm/index.js","webpack://food/./node_modules/@webassemblyjs/leb128/esm/bits.js","webpack://food/./node_modules/@webassemblyjs/leb128/esm/bufs.js","webpack://food/./node_modules/@webassemblyjs/leb128/esm/index.js","webpack://food/./node_modules/@webassemblyjs/leb128/esm/leb.js","webpack://food/./node_modules/@webassemblyjs/utf8/esm/decoder.js","webpack://food/./node_modules/@webassemblyjs/utf8/esm/encoder.js","webpack://food/./node_modules/@webassemblyjs/utf8/esm/index.js","webpack://food/./node_modules/@webassemblyjs/wasm-parser/lib/decoder.js","webpack://food/./node_modules/@xtuc/ieee754/index.js","webpack://food/./node_modules/@xtuc/long/src/long.js","webpack://food/webpack/bootstrap","webpack://food/webpack/runtime/compat get default export","webpack://food/webpack/runtime/define property getters","webpack://food/webpack/runtime/hasOwnProperty shorthand","webpack://food/webpack/runtime/make namespace object","webpack://food/./src/js/main.js"],"sourcesContent":["export function cloneNode(n) {\n  // $FlowIgnore\n  return Object.assign({}, n);\n}","export * from \"./nodes\";\nexport { numberLiteralFromRaw, withLoc, withRaw, funcParam, indexLiteral, memIndexLiteral, instruction, objectInstruction } from \"./node-helpers.js\";\nexport { traverse } from \"./traverse\";\nexport { signatures } from \"./signatures\";\nexport * from \"./utils\";\nexport { cloneNode } from \"./clone\";\nexport { moduleContextFromModuleAST } from \"./transform/ast-module-to-module-context\";","import { parse32F, parse64F, parse32I, parse64I, parseU32, isNanLiteral, isInfLiteral } from \"@webassemblyjs/helper-numbers\";\nimport { longNumberLiteral, floatLiteral, numberLiteral, instr } from \"./nodes\";\nexport function numberLiteralFromRaw(rawValue) {\n  var instructionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"i32\";\n  var original = rawValue; // Remove numeric separators _\n\n  if (typeof rawValue === \"string\") {\n    rawValue = rawValue.replace(/_/g, \"\");\n  }\n\n  if (typeof rawValue === \"number\") {\n    return numberLiteral(rawValue, String(original));\n  } else {\n    switch (instructionType) {\n      case \"i32\":\n        {\n          return numberLiteral(parse32I(rawValue), String(original));\n        }\n\n      case \"u32\":\n        {\n          return numberLiteral(parseU32(rawValue), String(original));\n        }\n\n      case \"i64\":\n        {\n          return longNumberLiteral(parse64I(rawValue), String(original));\n        }\n\n      case \"f32\":\n        {\n          return floatLiteral(parse32F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n      // f64\n\n      default:\n        {\n          return floatLiteral(parse64F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n    }\n  }\n}\nexport function instruction(id) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var namedArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return instr(id, undefined, args, namedArgs);\n}\nexport function objectInstruction(id, object) {\n  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var namedArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return instr(id, object, args, namedArgs);\n}\n/**\n * Decorators\n */\n\nexport function withLoc(n, end, start) {\n  var loc = {\n    start: start,\n    end: end\n  };\n  n.loc = loc;\n  return n;\n}\nexport function withRaw(n, raw) {\n  n.raw = raw;\n  return n;\n}\nexport function funcParam(valtype, id) {\n  return {\n    id: id,\n    valtype: valtype\n  };\n}\nexport function indexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, \"u32\");\n  return x;\n}\nexport function memIndexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, \"u32\");\n  return x;\n}","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction findParent(_ref, cb) {\n  var parentPath = _ref.parentPath;\n\n  if (parentPath == null) {\n    throw new Error(\"node is root\");\n  }\n\n  var currentPath = parentPath;\n\n  while (cb(currentPath) !== false) {\n    // Hit the root node, stop\n    // $FlowIgnore\n    if (currentPath.parentPath == null) {\n      return null;\n    } // $FlowIgnore\n\n\n    currentPath = currentPath.parentPath;\n  }\n\n  return currentPath.node;\n}\n\nfunction insertBefore(context, newNode) {\n  return insert(context, newNode);\n}\n\nfunction insertAfter(context, newNode) {\n  return insert(context, newNode, 1);\n}\n\nfunction insert(_ref2, newNode) {\n  var node = _ref2.node,\n      inList = _ref2.inList,\n      parentPath = _ref2.parentPath,\n      parentKey = _ref2.parentKey;\n  var indexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (!inList) {\n    throw new Error('inList' + \" error: \" + (\"insert can only be used for nodes that are within lists\" || \"unknown\"));\n  }\n\n  if (!(parentPath != null)) {\n    throw new Error('parentPath != null' + \" error: \" + (\"Can not remove root node\" || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  var parentList = parentPath.node[parentKey];\n  var indexInList = parentList.findIndex(function (n) {\n    return n === node;\n  });\n  parentList.splice(indexInList + indexOffset, 0, newNode);\n}\n\nfunction remove(_ref3) {\n  var node = _ref3.node,\n      parentKey = _ref3.parentKey,\n      parentPath = _ref3.parentPath;\n\n  if (!(parentPath != null)) {\n    throw new Error('parentPath != null' + \" error: \" + (\"Can not remove root node\" || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  var parentNode = parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[parentKey];\n\n  if (Array.isArray(parentProperty)) {\n    // $FlowIgnore\n    parentNode[parentKey] = parentProperty.filter(function (n) {\n      return n !== node;\n    });\n  } else {\n    // $FlowIgnore\n    delete parentNode[parentKey];\n  }\n\n  node._deleted = true;\n}\n\nfunction stop(context) {\n  context.shouldStop = true;\n}\n\nfunction replaceWith(context, newNode) {\n  // $FlowIgnore\n  var parentNode = context.parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[context.parentKey];\n\n  if (Array.isArray(parentProperty)) {\n    var indexInList = parentProperty.findIndex(function (n) {\n      return n === context.node;\n    });\n    parentProperty.splice(indexInList, 1, newNode);\n  } else {\n    // $FlowIgnore\n    parentNode[context.parentKey] = newNode;\n  }\n\n  context.node._deleted = true;\n  context.node = newNode;\n} // bind the context to the first argument of node operations\n\n\nfunction bindNodeOperations(operations, context) {\n  var keys = Object.keys(operations);\n  var boundOperations = {};\n  keys.forEach(function (key) {\n    boundOperations[key] = operations[key].bind(null, context);\n  });\n  return boundOperations;\n}\n\nfunction createPathOperations(context) {\n  // $FlowIgnore\n  return bindNodeOperations({\n    findParent: findParent,\n    replaceWith: replaceWith,\n    remove: remove,\n    insertBefore: insertBefore,\n    insertAfter: insertAfter,\n    stop: stop\n  }, context);\n}\n\nexport function createPath(context) {\n  var path = _objectSpread({}, context); // $FlowIgnore\n\n\n  Object.assign(path, createPathOperations(path)); // $FlowIgnore\n\n  return path;\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// THIS FILE IS AUTOGENERATED\n// see scripts/generateNodeUtils.js\nfunction isTypeOf(t) {\n  return function (n) {\n    return n.type === t;\n  };\n}\n\nfunction assertTypeOf(t) {\n  return function (n) {\n    return function () {\n      if (!(n.type === t)) {\n        throw new Error('n.type === t' + \" error: \" + (undefined || \"unknown\"));\n      }\n    }();\n  };\n}\n\nexport function module(id, fields, metadata) {\n  if (id !== null && id !== undefined) {\n    if (!(typeof id === \"string\")) {\n      throw new Error('typeof id === \"string\"' + \" error: \" + (\"Argument id must be of type string, given: \" + _typeof(id) || \"unknown\"));\n    }\n  }\n\n  if (!(_typeof(fields) === \"object\" && typeof fields.length !== \"undefined\")) {\n    throw new Error('typeof fields === \"object\" && typeof fields.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"Module\",\n    id: id,\n    fields: fields\n  };\n\n  if (typeof metadata !== \"undefined\") {\n    node.metadata = metadata;\n  }\n\n  return node;\n}\nexport function moduleMetadata(sections, functionNames, localNames, producers) {\n  if (!(_typeof(sections) === \"object\" && typeof sections.length !== \"undefined\")) {\n    throw new Error('typeof sections === \"object\" && typeof sections.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (functionNames !== null && functionNames !== undefined) {\n    if (!(_typeof(functionNames) === \"object\" && typeof functionNames.length !== \"undefined\")) {\n      throw new Error('typeof functionNames === \"object\" && typeof functionNames.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n    }\n  }\n\n  if (localNames !== null && localNames !== undefined) {\n    if (!(_typeof(localNames) === \"object\" && typeof localNames.length !== \"undefined\")) {\n      throw new Error('typeof localNames === \"object\" && typeof localNames.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n    }\n  }\n\n  if (producers !== null && producers !== undefined) {\n    if (!(_typeof(producers) === \"object\" && typeof producers.length !== \"undefined\")) {\n      throw new Error('typeof producers === \"object\" && typeof producers.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n    }\n  }\n\n  var node = {\n    type: \"ModuleMetadata\",\n    sections: sections\n  };\n\n  if (typeof functionNames !== \"undefined\" && functionNames.length > 0) {\n    node.functionNames = functionNames;\n  }\n\n  if (typeof localNames !== \"undefined\" && localNames.length > 0) {\n    node.localNames = localNames;\n  }\n\n  if (typeof producers !== \"undefined\" && producers.length > 0) {\n    node.producers = producers;\n  }\n\n  return node;\n}\nexport function moduleNameMetadata(value) {\n  if (!(typeof value === \"string\")) {\n    throw new Error('typeof value === \"string\"' + \" error: \" + (\"Argument value must be of type string, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"ModuleNameMetadata\",\n    value: value\n  };\n  return node;\n}\nexport function functionNameMetadata(value, index) {\n  if (!(typeof value === \"string\")) {\n    throw new Error('typeof value === \"string\"' + \" error: \" + (\"Argument value must be of type string, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  if (!(typeof index === \"number\")) {\n    throw new Error('typeof index === \"number\"' + \" error: \" + (\"Argument index must be of type number, given: \" + _typeof(index) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"FunctionNameMetadata\",\n    value: value,\n    index: index\n  };\n  return node;\n}\nexport function localNameMetadata(value, localIndex, functionIndex) {\n  if (!(typeof value === \"string\")) {\n    throw new Error('typeof value === \"string\"' + \" error: \" + (\"Argument value must be of type string, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  if (!(typeof localIndex === \"number\")) {\n    throw new Error('typeof localIndex === \"number\"' + \" error: \" + (\"Argument localIndex must be of type number, given: \" + _typeof(localIndex) || \"unknown\"));\n  }\n\n  if (!(typeof functionIndex === \"number\")) {\n    throw new Error('typeof functionIndex === \"number\"' + \" error: \" + (\"Argument functionIndex must be of type number, given: \" + _typeof(functionIndex) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"LocalNameMetadata\",\n    value: value,\n    localIndex: localIndex,\n    functionIndex: functionIndex\n  };\n  return node;\n}\nexport function binaryModule(id, blob) {\n  if (id !== null && id !== undefined) {\n    if (!(typeof id === \"string\")) {\n      throw new Error('typeof id === \"string\"' + \" error: \" + (\"Argument id must be of type string, given: \" + _typeof(id) || \"unknown\"));\n    }\n  }\n\n  if (!(_typeof(blob) === \"object\" && typeof blob.length !== \"undefined\")) {\n    throw new Error('typeof blob === \"object\" && typeof blob.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"BinaryModule\",\n    id: id,\n    blob: blob\n  };\n  return node;\n}\nexport function quoteModule(id, string) {\n  if (id !== null && id !== undefined) {\n    if (!(typeof id === \"string\")) {\n      throw new Error('typeof id === \"string\"' + \" error: \" + (\"Argument id must be of type string, given: \" + _typeof(id) || \"unknown\"));\n    }\n  }\n\n  if (!(_typeof(string) === \"object\" && typeof string.length !== \"undefined\")) {\n    throw new Error('typeof string === \"object\" && typeof string.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"QuoteModule\",\n    id: id,\n    string: string\n  };\n  return node;\n}\nexport function sectionMetadata(section, startOffset, size, vectorOfSize) {\n  if (!(typeof startOffset === \"number\")) {\n    throw new Error('typeof startOffset === \"number\"' + \" error: \" + (\"Argument startOffset must be of type number, given: \" + _typeof(startOffset) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"SectionMetadata\",\n    section: section,\n    startOffset: startOffset,\n    size: size,\n    vectorOfSize: vectorOfSize\n  };\n  return node;\n}\nexport function producersSectionMetadata(producers) {\n  if (!(_typeof(producers) === \"object\" && typeof producers.length !== \"undefined\")) {\n    throw new Error('typeof producers === \"object\" && typeof producers.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"ProducersSectionMetadata\",\n    producers: producers\n  };\n  return node;\n}\nexport function producerMetadata(language, processedBy, sdk) {\n  if (!(_typeof(language) === \"object\" && typeof language.length !== \"undefined\")) {\n    throw new Error('typeof language === \"object\" && typeof language.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (!(_typeof(processedBy) === \"object\" && typeof processedBy.length !== \"undefined\")) {\n    throw new Error('typeof processedBy === \"object\" && typeof processedBy.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (!(_typeof(sdk) === \"object\" && typeof sdk.length !== \"undefined\")) {\n    throw new Error('typeof sdk === \"object\" && typeof sdk.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"ProducerMetadata\",\n    language: language,\n    processedBy: processedBy,\n    sdk: sdk\n  };\n  return node;\n}\nexport function producerMetadataVersionedName(name, version) {\n  if (!(typeof name === \"string\")) {\n    throw new Error('typeof name === \"string\"' + \" error: \" + (\"Argument name must be of type string, given: \" + _typeof(name) || \"unknown\"));\n  }\n\n  if (!(typeof version === \"string\")) {\n    throw new Error('typeof version === \"string\"' + \" error: \" + (\"Argument version must be of type string, given: \" + _typeof(version) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"ProducerMetadataVersionedName\",\n    name: name,\n    version: version\n  };\n  return node;\n}\nexport function loopInstruction(label, resulttype, instr) {\n  if (!(_typeof(instr) === \"object\" && typeof instr.length !== \"undefined\")) {\n    throw new Error('typeof instr === \"object\" && typeof instr.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"LoopInstruction\",\n    id: \"loop\",\n    label: label,\n    resulttype: resulttype,\n    instr: instr\n  };\n  return node;\n}\nexport function instr(id, object, args, namedArgs) {\n  if (!(typeof id === \"string\")) {\n    throw new Error('typeof id === \"string\"' + \" error: \" + (\"Argument id must be of type string, given: \" + _typeof(id) || \"unknown\"));\n  }\n\n  if (!(_typeof(args) === \"object\" && typeof args.length !== \"undefined\")) {\n    throw new Error('typeof args === \"object\" && typeof args.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"Instr\",\n    id: id,\n    args: args\n  };\n\n  if (typeof object !== \"undefined\") {\n    node.object = object;\n  }\n\n  if (typeof namedArgs !== \"undefined\" && Object.keys(namedArgs).length !== 0) {\n    node.namedArgs = namedArgs;\n  }\n\n  return node;\n}\nexport function ifInstruction(testLabel, test, result, consequent, alternate) {\n  if (!(_typeof(test) === \"object\" && typeof test.length !== \"undefined\")) {\n    throw new Error('typeof test === \"object\" && typeof test.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (!(_typeof(consequent) === \"object\" && typeof consequent.length !== \"undefined\")) {\n    throw new Error('typeof consequent === \"object\" && typeof consequent.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (!(_typeof(alternate) === \"object\" && typeof alternate.length !== \"undefined\")) {\n    throw new Error('typeof alternate === \"object\" && typeof alternate.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"IfInstruction\",\n    id: \"if\",\n    testLabel: testLabel,\n    test: test,\n    result: result,\n    consequent: consequent,\n    alternate: alternate\n  };\n  return node;\n}\nexport function stringLiteral(value) {\n  if (!(typeof value === \"string\")) {\n    throw new Error('typeof value === \"string\"' + \" error: \" + (\"Argument value must be of type string, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"StringLiteral\",\n    value: value\n  };\n  return node;\n}\nexport function numberLiteral(value, raw) {\n  if (!(typeof value === \"number\")) {\n    throw new Error('typeof value === \"number\"' + \" error: \" + (\"Argument value must be of type number, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  if (!(typeof raw === \"string\")) {\n    throw new Error('typeof raw === \"string\"' + \" error: \" + (\"Argument raw must be of type string, given: \" + _typeof(raw) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"NumberLiteral\",\n    value: value,\n    raw: raw\n  };\n  return node;\n}\nexport function longNumberLiteral(value, raw) {\n  if (!(typeof raw === \"string\")) {\n    throw new Error('typeof raw === \"string\"' + \" error: \" + (\"Argument raw must be of type string, given: \" + _typeof(raw) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"LongNumberLiteral\",\n    value: value,\n    raw: raw\n  };\n  return node;\n}\nexport function floatLiteral(value, nan, inf, raw) {\n  if (!(typeof value === \"number\")) {\n    throw new Error('typeof value === \"number\"' + \" error: \" + (\"Argument value must be of type number, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  if (nan !== null && nan !== undefined) {\n    if (!(typeof nan === \"boolean\")) {\n      throw new Error('typeof nan === \"boolean\"' + \" error: \" + (\"Argument nan must be of type boolean, given: \" + _typeof(nan) || \"unknown\"));\n    }\n  }\n\n  if (inf !== null && inf !== undefined) {\n    if (!(typeof inf === \"boolean\")) {\n      throw new Error('typeof inf === \"boolean\"' + \" error: \" + (\"Argument inf must be of type boolean, given: \" + _typeof(inf) || \"unknown\"));\n    }\n  }\n\n  if (!(typeof raw === \"string\")) {\n    throw new Error('typeof raw === \"string\"' + \" error: \" + (\"Argument raw must be of type string, given: \" + _typeof(raw) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"FloatLiteral\",\n    value: value,\n    raw: raw\n  };\n\n  if (nan === true) {\n    node.nan = true;\n  }\n\n  if (inf === true) {\n    node.inf = true;\n  }\n\n  return node;\n}\nexport function elem(table, offset, funcs) {\n  if (!(_typeof(offset) === \"object\" && typeof offset.length !== \"undefined\")) {\n    throw new Error('typeof offset === \"object\" && typeof offset.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (!(_typeof(funcs) === \"object\" && typeof funcs.length !== \"undefined\")) {\n    throw new Error('typeof funcs === \"object\" && typeof funcs.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"Elem\",\n    table: table,\n    offset: offset,\n    funcs: funcs\n  };\n  return node;\n}\nexport function indexInFuncSection(index) {\n  var node = {\n    type: \"IndexInFuncSection\",\n    index: index\n  };\n  return node;\n}\nexport function valtypeLiteral(name) {\n  var node = {\n    type: \"ValtypeLiteral\",\n    name: name\n  };\n  return node;\n}\nexport function typeInstruction(id, functype) {\n  var node = {\n    type: \"TypeInstruction\",\n    id: id,\n    functype: functype\n  };\n  return node;\n}\nexport function start(index) {\n  var node = {\n    type: \"Start\",\n    index: index\n  };\n  return node;\n}\nexport function globalType(valtype, mutability) {\n  var node = {\n    type: \"GlobalType\",\n    valtype: valtype,\n    mutability: mutability\n  };\n  return node;\n}\nexport function leadingComment(value) {\n  if (!(typeof value === \"string\")) {\n    throw new Error('typeof value === \"string\"' + \" error: \" + (\"Argument value must be of type string, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"LeadingComment\",\n    value: value\n  };\n  return node;\n}\nexport function blockComment(value) {\n  if (!(typeof value === \"string\")) {\n    throw new Error('typeof value === \"string\"' + \" error: \" + (\"Argument value must be of type string, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"BlockComment\",\n    value: value\n  };\n  return node;\n}\nexport function data(memoryIndex, offset, init) {\n  var node = {\n    type: \"Data\",\n    memoryIndex: memoryIndex,\n    offset: offset,\n    init: init\n  };\n  return node;\n}\nexport function global(globalType, init, name) {\n  if (!(_typeof(init) === \"object\" && typeof init.length !== \"undefined\")) {\n    throw new Error('typeof init === \"object\" && typeof init.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"Global\",\n    globalType: globalType,\n    init: init,\n    name: name\n  };\n  return node;\n}\nexport function table(elementType, limits, name, elements) {\n  if (!(limits.type === \"Limit\")) {\n    throw new Error('limits.type === \"Limit\"' + \" error: \" + (\"Argument limits must be of type Limit, given: \" + limits.type || \"unknown\"));\n  }\n\n  if (elements !== null && elements !== undefined) {\n    if (!(_typeof(elements) === \"object\" && typeof elements.length !== \"undefined\")) {\n      throw new Error('typeof elements === \"object\" && typeof elements.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n    }\n  }\n\n  var node = {\n    type: \"Table\",\n    elementType: elementType,\n    limits: limits,\n    name: name\n  };\n\n  if (typeof elements !== \"undefined\" && elements.length > 0) {\n    node.elements = elements;\n  }\n\n  return node;\n}\nexport function memory(limits, id) {\n  var node = {\n    type: \"Memory\",\n    limits: limits,\n    id: id\n  };\n  return node;\n}\nexport function funcImportDescr(id, signature) {\n  var node = {\n    type: \"FuncImportDescr\",\n    id: id,\n    signature: signature\n  };\n  return node;\n}\nexport function moduleImport(module, name, descr) {\n  if (!(typeof module === \"string\")) {\n    throw new Error('typeof module === \"string\"' + \" error: \" + (\"Argument module must be of type string, given: \" + _typeof(module) || \"unknown\"));\n  }\n\n  if (!(typeof name === \"string\")) {\n    throw new Error('typeof name === \"string\"' + \" error: \" + (\"Argument name must be of type string, given: \" + _typeof(name) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"ModuleImport\",\n    module: module,\n    name: name,\n    descr: descr\n  };\n  return node;\n}\nexport function moduleExportDescr(exportType, id) {\n  var node = {\n    type: \"ModuleExportDescr\",\n    exportType: exportType,\n    id: id\n  };\n  return node;\n}\nexport function moduleExport(name, descr) {\n  if (!(typeof name === \"string\")) {\n    throw new Error('typeof name === \"string\"' + \" error: \" + (\"Argument name must be of type string, given: \" + _typeof(name) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"ModuleExport\",\n    name: name,\n    descr: descr\n  };\n  return node;\n}\nexport function limit(min, max, shared) {\n  if (!(typeof min === \"number\")) {\n    throw new Error('typeof min === \"number\"' + \" error: \" + (\"Argument min must be of type number, given: \" + _typeof(min) || \"unknown\"));\n  }\n\n  if (max !== null && max !== undefined) {\n    if (!(typeof max === \"number\")) {\n      throw new Error('typeof max === \"number\"' + \" error: \" + (\"Argument max must be of type number, given: \" + _typeof(max) || \"unknown\"));\n    }\n  }\n\n  if (shared !== null && shared !== undefined) {\n    if (!(typeof shared === \"boolean\")) {\n      throw new Error('typeof shared === \"boolean\"' + \" error: \" + (\"Argument shared must be of type boolean, given: \" + _typeof(shared) || \"unknown\"));\n    }\n  }\n\n  var node = {\n    type: \"Limit\",\n    min: min\n  };\n\n  if (typeof max !== \"undefined\") {\n    node.max = max;\n  }\n\n  if (shared === true) {\n    node.shared = true;\n  }\n\n  return node;\n}\nexport function signature(params, results) {\n  if (!(_typeof(params) === \"object\" && typeof params.length !== \"undefined\")) {\n    throw new Error('typeof params === \"object\" && typeof params.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (!(_typeof(results) === \"object\" && typeof results.length !== \"undefined\")) {\n    throw new Error('typeof results === \"object\" && typeof results.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"Signature\",\n    params: params,\n    results: results\n  };\n  return node;\n}\nexport function program(body) {\n  if (!(_typeof(body) === \"object\" && typeof body.length !== \"undefined\")) {\n    throw new Error('typeof body === \"object\" && typeof body.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"Program\",\n    body: body\n  };\n  return node;\n}\nexport function identifier(value, raw) {\n  if (!(typeof value === \"string\")) {\n    throw new Error('typeof value === \"string\"' + \" error: \" + (\"Argument value must be of type string, given: \" + _typeof(value) || \"unknown\"));\n  }\n\n  if (raw !== null && raw !== undefined) {\n    if (!(typeof raw === \"string\")) {\n      throw new Error('typeof raw === \"string\"' + \" error: \" + (\"Argument raw must be of type string, given: \" + _typeof(raw) || \"unknown\"));\n    }\n  }\n\n  var node = {\n    type: \"Identifier\",\n    value: value\n  };\n\n  if (typeof raw !== \"undefined\") {\n    node.raw = raw;\n  }\n\n  return node;\n}\nexport function blockInstruction(label, instr, result) {\n  if (!(_typeof(instr) === \"object\" && typeof instr.length !== \"undefined\")) {\n    throw new Error('typeof instr === \"object\" && typeof instr.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"BlockInstruction\",\n    id: \"block\",\n    label: label,\n    instr: instr,\n    result: result\n  };\n  return node;\n}\nexport function callInstruction(index, instrArgs, numeric) {\n  if (instrArgs !== null && instrArgs !== undefined) {\n    if (!(_typeof(instrArgs) === \"object\" && typeof instrArgs.length !== \"undefined\")) {\n      throw new Error('typeof instrArgs === \"object\" && typeof instrArgs.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n    }\n  }\n\n  var node = {\n    type: \"CallInstruction\",\n    id: \"call\",\n    index: index\n  };\n\n  if (typeof instrArgs !== \"undefined\" && instrArgs.length > 0) {\n    node.instrArgs = instrArgs;\n  }\n\n  if (typeof numeric !== \"undefined\") {\n    node.numeric = numeric;\n  }\n\n  return node;\n}\nexport function callIndirectInstruction(signature, intrs) {\n  if (intrs !== null && intrs !== undefined) {\n    if (!(_typeof(intrs) === \"object\" && typeof intrs.length !== \"undefined\")) {\n      throw new Error('typeof intrs === \"object\" && typeof intrs.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n    }\n  }\n\n  var node = {\n    type: \"CallIndirectInstruction\",\n    id: \"call_indirect\",\n    signature: signature\n  };\n\n  if (typeof intrs !== \"undefined\" && intrs.length > 0) {\n    node.intrs = intrs;\n  }\n\n  return node;\n}\nexport function byteArray(values) {\n  if (!(_typeof(values) === \"object\" && typeof values.length !== \"undefined\")) {\n    throw new Error('typeof values === \"object\" && typeof values.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var node = {\n    type: \"ByteArray\",\n    values: values\n  };\n  return node;\n}\nexport function func(name, signature, body, isExternal, metadata) {\n  if (!(_typeof(body) === \"object\" && typeof body.length !== \"undefined\")) {\n    throw new Error('typeof body === \"object\" && typeof body.length !== \"undefined\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  if (isExternal !== null && isExternal !== undefined) {\n    if (!(typeof isExternal === \"boolean\")) {\n      throw new Error('typeof isExternal === \"boolean\"' + \" error: \" + (\"Argument isExternal must be of type boolean, given: \" + _typeof(isExternal) || \"unknown\"));\n    }\n  }\n\n  var node = {\n    type: \"Func\",\n    name: name,\n    signature: signature,\n    body: body\n  };\n\n  if (isExternal === true) {\n    node.isExternal = true;\n  }\n\n  if (typeof metadata !== \"undefined\") {\n    node.metadata = metadata;\n  }\n\n  return node;\n}\nexport function internalBrUnless(target) {\n  if (!(typeof target === \"number\")) {\n    throw new Error('typeof target === \"number\"' + \" error: \" + (\"Argument target must be of type number, given: \" + _typeof(target) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"InternalBrUnless\",\n    target: target\n  };\n  return node;\n}\nexport function internalGoto(target) {\n  if (!(typeof target === \"number\")) {\n    throw new Error('typeof target === \"number\"' + \" error: \" + (\"Argument target must be of type number, given: \" + _typeof(target) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"InternalGoto\",\n    target: target\n  };\n  return node;\n}\nexport function internalCallExtern(target) {\n  if (!(typeof target === \"number\")) {\n    throw new Error('typeof target === \"number\"' + \" error: \" + (\"Argument target must be of type number, given: \" + _typeof(target) || \"unknown\"));\n  }\n\n  var node = {\n    type: \"InternalCallExtern\",\n    target: target\n  };\n  return node;\n}\nexport function internalEndAndReturn() {\n  var node = {\n    type: \"InternalEndAndReturn\"\n  };\n  return node;\n}\nexport var isModule = isTypeOf(\"Module\");\nexport var isModuleMetadata = isTypeOf(\"ModuleMetadata\");\nexport var isModuleNameMetadata = isTypeOf(\"ModuleNameMetadata\");\nexport var isFunctionNameMetadata = isTypeOf(\"FunctionNameMetadata\");\nexport var isLocalNameMetadata = isTypeOf(\"LocalNameMetadata\");\nexport var isBinaryModule = isTypeOf(\"BinaryModule\");\nexport var isQuoteModule = isTypeOf(\"QuoteModule\");\nexport var isSectionMetadata = isTypeOf(\"SectionMetadata\");\nexport var isProducersSectionMetadata = isTypeOf(\"ProducersSectionMetadata\");\nexport var isProducerMetadata = isTypeOf(\"ProducerMetadata\");\nexport var isProducerMetadataVersionedName = isTypeOf(\"ProducerMetadataVersionedName\");\nexport var isLoopInstruction = isTypeOf(\"LoopInstruction\");\nexport var isInstr = isTypeOf(\"Instr\");\nexport var isIfInstruction = isTypeOf(\"IfInstruction\");\nexport var isStringLiteral = isTypeOf(\"StringLiteral\");\nexport var isNumberLiteral = isTypeOf(\"NumberLiteral\");\nexport var isLongNumberLiteral = isTypeOf(\"LongNumberLiteral\");\nexport var isFloatLiteral = isTypeOf(\"FloatLiteral\");\nexport var isElem = isTypeOf(\"Elem\");\nexport var isIndexInFuncSection = isTypeOf(\"IndexInFuncSection\");\nexport var isValtypeLiteral = isTypeOf(\"ValtypeLiteral\");\nexport var isTypeInstruction = isTypeOf(\"TypeInstruction\");\nexport var isStart = isTypeOf(\"Start\");\nexport var isGlobalType = isTypeOf(\"GlobalType\");\nexport var isLeadingComment = isTypeOf(\"LeadingComment\");\nexport var isBlockComment = isTypeOf(\"BlockComment\");\nexport var isData = isTypeOf(\"Data\");\nexport var isGlobal = isTypeOf(\"Global\");\nexport var isTable = isTypeOf(\"Table\");\nexport var isMemory = isTypeOf(\"Memory\");\nexport var isFuncImportDescr = isTypeOf(\"FuncImportDescr\");\nexport var isModuleImport = isTypeOf(\"ModuleImport\");\nexport var isModuleExportDescr = isTypeOf(\"ModuleExportDescr\");\nexport var isModuleExport = isTypeOf(\"ModuleExport\");\nexport var isLimit = isTypeOf(\"Limit\");\nexport var isSignature = isTypeOf(\"Signature\");\nexport var isProgram = isTypeOf(\"Program\");\nexport var isIdentifier = isTypeOf(\"Identifier\");\nexport var isBlockInstruction = isTypeOf(\"BlockInstruction\");\nexport var isCallInstruction = isTypeOf(\"CallInstruction\");\nexport var isCallIndirectInstruction = isTypeOf(\"CallIndirectInstruction\");\nexport var isByteArray = isTypeOf(\"ByteArray\");\nexport var isFunc = isTypeOf(\"Func\");\nexport var isInternalBrUnless = isTypeOf(\"InternalBrUnless\");\nexport var isInternalGoto = isTypeOf(\"InternalGoto\");\nexport var isInternalCallExtern = isTypeOf(\"InternalCallExtern\");\nexport var isInternalEndAndReturn = isTypeOf(\"InternalEndAndReturn\");\nexport var isNode = function isNode(node) {\n  return isModule(node) || isModuleMetadata(node) || isModuleNameMetadata(node) || isFunctionNameMetadata(node) || isLocalNameMetadata(node) || isBinaryModule(node) || isQuoteModule(node) || isSectionMetadata(node) || isProducersSectionMetadata(node) || isProducerMetadata(node) || isProducerMetadataVersionedName(node) || isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isElem(node) || isIndexInFuncSection(node) || isValtypeLiteral(node) || isTypeInstruction(node) || isStart(node) || isGlobalType(node) || isLeadingComment(node) || isBlockComment(node) || isData(node) || isGlobal(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node) || isModuleImport(node) || isModuleExportDescr(node) || isModuleExport(node) || isLimit(node) || isSignature(node) || isProgram(node) || isIdentifier(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node) || isByteArray(node) || isFunc(node) || isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);\n};\nexport var isBlock = function isBlock(node) {\n  return isLoopInstruction(node) || isBlockInstruction(node) || isFunc(node);\n};\nexport var isInstruction = function isInstruction(node) {\n  return isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isTypeInstruction(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node);\n};\nexport var isExpression = function isExpression(node) {\n  return isInstr(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isValtypeLiteral(node) || isIdentifier(node);\n};\nexport var isNumericLiteral = function isNumericLiteral(node) {\n  return isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node);\n};\nexport var isImportDescr = function isImportDescr(node) {\n  return isGlobalType(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node);\n};\nexport var isIntrinsic = function isIntrinsic(node) {\n  return isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);\n};\nexport var assertModule = assertTypeOf(\"Module\");\nexport var assertModuleMetadata = assertTypeOf(\"ModuleMetadata\");\nexport var assertModuleNameMetadata = assertTypeOf(\"ModuleNameMetadata\");\nexport var assertFunctionNameMetadata = assertTypeOf(\"FunctionNameMetadata\");\nexport var assertLocalNameMetadata = assertTypeOf(\"LocalNameMetadata\");\nexport var assertBinaryModule = assertTypeOf(\"BinaryModule\");\nexport var assertQuoteModule = assertTypeOf(\"QuoteModule\");\nexport var assertSectionMetadata = assertTypeOf(\"SectionMetadata\");\nexport var assertProducersSectionMetadata = assertTypeOf(\"ProducersSectionMetadata\");\nexport var assertProducerMetadata = assertTypeOf(\"ProducerMetadata\");\nexport var assertProducerMetadataVersionedName = assertTypeOf(\"ProducerMetadataVersionedName\");\nexport var assertLoopInstruction = assertTypeOf(\"LoopInstruction\");\nexport var assertInstr = assertTypeOf(\"Instr\");\nexport var assertIfInstruction = assertTypeOf(\"IfInstruction\");\nexport var assertStringLiteral = assertTypeOf(\"StringLiteral\");\nexport var assertNumberLiteral = assertTypeOf(\"NumberLiteral\");\nexport var assertLongNumberLiteral = assertTypeOf(\"LongNumberLiteral\");\nexport var assertFloatLiteral = assertTypeOf(\"FloatLiteral\");\nexport var assertElem = assertTypeOf(\"Elem\");\nexport var assertIndexInFuncSection = assertTypeOf(\"IndexInFuncSection\");\nexport var assertValtypeLiteral = assertTypeOf(\"ValtypeLiteral\");\nexport var assertTypeInstruction = assertTypeOf(\"TypeInstruction\");\nexport var assertStart = assertTypeOf(\"Start\");\nexport var assertGlobalType = assertTypeOf(\"GlobalType\");\nexport var assertLeadingComment = assertTypeOf(\"LeadingComment\");\nexport var assertBlockComment = assertTypeOf(\"BlockComment\");\nexport var assertData = assertTypeOf(\"Data\");\nexport var assertGlobal = assertTypeOf(\"Global\");\nexport var assertTable = assertTypeOf(\"Table\");\nexport var assertMemory = assertTypeOf(\"Memory\");\nexport var assertFuncImportDescr = assertTypeOf(\"FuncImportDescr\");\nexport var assertModuleImport = assertTypeOf(\"ModuleImport\");\nexport var assertModuleExportDescr = assertTypeOf(\"ModuleExportDescr\");\nexport var assertModuleExport = assertTypeOf(\"ModuleExport\");\nexport var assertLimit = assertTypeOf(\"Limit\");\nexport var assertSignature = assertTypeOf(\"Signature\");\nexport var assertProgram = assertTypeOf(\"Program\");\nexport var assertIdentifier = assertTypeOf(\"Identifier\");\nexport var assertBlockInstruction = assertTypeOf(\"BlockInstruction\");\nexport var assertCallInstruction = assertTypeOf(\"CallInstruction\");\nexport var assertCallIndirectInstruction = assertTypeOf(\"CallIndirectInstruction\");\nexport var assertByteArray = assertTypeOf(\"ByteArray\");\nexport var assertFunc = assertTypeOf(\"Func\");\nexport var assertInternalBrUnless = assertTypeOf(\"InternalBrUnless\");\nexport var assertInternalGoto = assertTypeOf(\"InternalGoto\");\nexport var assertInternalCallExtern = assertTypeOf(\"InternalCallExtern\");\nexport var assertInternalEndAndReturn = assertTypeOf(\"InternalEndAndReturn\");\nexport var unionTypesMap = {\n  Module: [\"Node\"],\n  ModuleMetadata: [\"Node\"],\n  ModuleNameMetadata: [\"Node\"],\n  FunctionNameMetadata: [\"Node\"],\n  LocalNameMetadata: [\"Node\"],\n  BinaryModule: [\"Node\"],\n  QuoteModule: [\"Node\"],\n  SectionMetadata: [\"Node\"],\n  ProducersSectionMetadata: [\"Node\"],\n  ProducerMetadata: [\"Node\"],\n  ProducerMetadataVersionedName: [\"Node\"],\n  LoopInstruction: [\"Node\", \"Block\", \"Instruction\"],\n  Instr: [\"Node\", \"Expression\", \"Instruction\"],\n  IfInstruction: [\"Node\", \"Instruction\"],\n  StringLiteral: [\"Node\", \"Expression\"],\n  NumberLiteral: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  LongNumberLiteral: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  FloatLiteral: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  Elem: [\"Node\"],\n  IndexInFuncSection: [\"Node\"],\n  ValtypeLiteral: [\"Node\", \"Expression\"],\n  TypeInstruction: [\"Node\", \"Instruction\"],\n  Start: [\"Node\"],\n  GlobalType: [\"Node\", \"ImportDescr\"],\n  LeadingComment: [\"Node\"],\n  BlockComment: [\"Node\"],\n  Data: [\"Node\"],\n  Global: [\"Node\"],\n  Table: [\"Node\", \"ImportDescr\"],\n  Memory: [\"Node\", \"ImportDescr\"],\n  FuncImportDescr: [\"Node\", \"ImportDescr\"],\n  ModuleImport: [\"Node\"],\n  ModuleExportDescr: [\"Node\"],\n  ModuleExport: [\"Node\"],\n  Limit: [\"Node\"],\n  Signature: [\"Node\"],\n  Program: [\"Node\"],\n  Identifier: [\"Node\", \"Expression\"],\n  BlockInstruction: [\"Node\", \"Block\", \"Instruction\"],\n  CallInstruction: [\"Node\", \"Instruction\"],\n  CallIndirectInstruction: [\"Node\", \"Instruction\"],\n  ByteArray: [\"Node\"],\n  Func: [\"Node\", \"Block\"],\n  InternalBrUnless: [\"Node\", \"Intrinsic\"],\n  InternalGoto: [\"Node\", \"Intrinsic\"],\n  InternalCallExtern: [\"Node\", \"Intrinsic\"],\n  InternalEndAndReturn: [\"Node\", \"Intrinsic\"]\n};\nexport var nodeAndUnionTypes = [\"Module\", \"ModuleMetadata\", \"ModuleNameMetadata\", \"FunctionNameMetadata\", \"LocalNameMetadata\", \"BinaryModule\", \"QuoteModule\", \"SectionMetadata\", \"ProducersSectionMetadata\", \"ProducerMetadata\", \"ProducerMetadataVersionedName\", \"LoopInstruction\", \"Instr\", \"IfInstruction\", \"StringLiteral\", \"NumberLiteral\", \"LongNumberLiteral\", \"FloatLiteral\", \"Elem\", \"IndexInFuncSection\", \"ValtypeLiteral\", \"TypeInstruction\", \"Start\", \"GlobalType\", \"LeadingComment\", \"BlockComment\", \"Data\", \"Global\", \"Table\", \"Memory\", \"FuncImportDescr\", \"ModuleImport\", \"ModuleExportDescr\", \"ModuleExport\", \"Limit\", \"Signature\", \"Program\", \"Identifier\", \"BlockInstruction\", \"CallInstruction\", \"CallIndirectInstruction\", \"ByteArray\", \"Func\", \"InternalBrUnless\", \"InternalGoto\", \"InternalCallExtern\", \"InternalEndAndReturn\", \"Node\", \"Block\", \"Instruction\", \"Expression\", \"NumericLiteral\", \"ImportDescr\", \"Intrinsic\"];","function sign(input, output) {\n  return [input, output];\n}\n\nvar u32 = \"u32\";\nvar i32 = \"i32\";\nvar i64 = \"i64\";\nvar f32 = \"f32\";\nvar f64 = \"f64\";\n\nvar vector = function vector(t) {\n  var vecType = [t]; // $FlowIgnore\n\n  vecType.vector = true;\n  return vecType;\n};\n\nvar controlInstructions = {\n  unreachable: sign([], []),\n  nop: sign([], []),\n  // block ?\n  // loop ?\n  // if ?\n  // if else ?\n  br: sign([u32], []),\n  br_if: sign([u32], []),\n  br_table: sign(vector(u32), []),\n  \"return\": sign([], []),\n  call: sign([u32], []),\n  call_indirect: sign([u32], [])\n};\nvar parametricInstructions = {\n  drop: sign([], []),\n  select: sign([], [])\n};\nvar variableInstructions = {\n  get_local: sign([u32], []),\n  set_local: sign([u32], []),\n  tee_local: sign([u32], []),\n  get_global: sign([u32], []),\n  set_global: sign([u32], [])\n};\nvar memoryInstructions = {\n  \"i32.load\": sign([u32, u32], [i32]),\n  \"i64.load\": sign([u32, u32], []),\n  \"f32.load\": sign([u32, u32], []),\n  \"f64.load\": sign([u32, u32], []),\n  \"i32.load8_s\": sign([u32, u32], [i32]),\n  \"i32.load8_u\": sign([u32, u32], [i32]),\n  \"i32.load16_s\": sign([u32, u32], [i32]),\n  \"i32.load16_u\": sign([u32, u32], [i32]),\n  \"i64.load8_s\": sign([u32, u32], [i64]),\n  \"i64.load8_u\": sign([u32, u32], [i64]),\n  \"i64.load16_s\": sign([u32, u32], [i64]),\n  \"i64.load16_u\": sign([u32, u32], [i64]),\n  \"i64.load32_s\": sign([u32, u32], [i64]),\n  \"i64.load32_u\": sign([u32, u32], [i64]),\n  \"i32.store\": sign([u32, u32], []),\n  \"i64.store\": sign([u32, u32], []),\n  \"f32.store\": sign([u32, u32], []),\n  \"f64.store\": sign([u32, u32], []),\n  \"i32.store8\": sign([u32, u32], []),\n  \"i32.store16\": sign([u32, u32], []),\n  \"i64.store8\": sign([u32, u32], []),\n  \"i64.store16\": sign([u32, u32], []),\n  \"i64.store32\": sign([u32, u32], []),\n  current_memory: sign([], []),\n  grow_memory: sign([], [])\n};\nvar numericInstructions = {\n  \"i32.const\": sign([i32], [i32]),\n  \"i64.const\": sign([i64], [i64]),\n  \"f32.const\": sign([f32], [f32]),\n  \"f64.const\": sign([f64], [f64]),\n  \"i32.eqz\": sign([i32], [i32]),\n  \"i32.eq\": sign([i32, i32], [i32]),\n  \"i32.ne\": sign([i32, i32], [i32]),\n  \"i32.lt_s\": sign([i32, i32], [i32]),\n  \"i32.lt_u\": sign([i32, i32], [i32]),\n  \"i32.gt_s\": sign([i32, i32], [i32]),\n  \"i32.gt_u\": sign([i32, i32], [i32]),\n  \"i32.le_s\": sign([i32, i32], [i32]),\n  \"i32.le_u\": sign([i32, i32], [i32]),\n  \"i32.ge_s\": sign([i32, i32], [i32]),\n  \"i32.ge_u\": sign([i32, i32], [i32]),\n  \"i64.eqz\": sign([i64], [i64]),\n  \"i64.eq\": sign([i64, i64], [i32]),\n  \"i64.ne\": sign([i64, i64], [i32]),\n  \"i64.lt_s\": sign([i64, i64], [i32]),\n  \"i64.lt_u\": sign([i64, i64], [i32]),\n  \"i64.gt_s\": sign([i64, i64], [i32]),\n  \"i64.gt_u\": sign([i64, i64], [i32]),\n  \"i64.le_s\": sign([i64, i64], [i32]),\n  \"i64.le_u\": sign([i64, i64], [i32]),\n  \"i64.ge_s\": sign([i64, i64], [i32]),\n  \"i64.ge_u\": sign([i64, i64], [i32]),\n  \"f32.eq\": sign([f32, f32], [i32]),\n  \"f32.ne\": sign([f32, f32], [i32]),\n  \"f32.lt\": sign([f32, f32], [i32]),\n  \"f32.gt\": sign([f32, f32], [i32]),\n  \"f32.le\": sign([f32, f32], [i32]),\n  \"f32.ge\": sign([f32, f32], [i32]),\n  \"f64.eq\": sign([f64, f64], [i32]),\n  \"f64.ne\": sign([f64, f64], [i32]),\n  \"f64.lt\": sign([f64, f64], [i32]),\n  \"f64.gt\": sign([f64, f64], [i32]),\n  \"f64.le\": sign([f64, f64], [i32]),\n  \"f64.ge\": sign([f64, f64], [i32]),\n  \"i32.clz\": sign([i32], [i32]),\n  \"i32.ctz\": sign([i32], [i32]),\n  \"i32.popcnt\": sign([i32], [i32]),\n  \"i32.add\": sign([i32, i32], [i32]),\n  \"i32.sub\": sign([i32, i32], [i32]),\n  \"i32.mul\": sign([i32, i32], [i32]),\n  \"i32.div_s\": sign([i32, i32], [i32]),\n  \"i32.div_u\": sign([i32, i32], [i32]),\n  \"i32.rem_s\": sign([i32, i32], [i32]),\n  \"i32.rem_u\": sign([i32, i32], [i32]),\n  \"i32.and\": sign([i32, i32], [i32]),\n  \"i32.or\": sign([i32, i32], [i32]),\n  \"i32.xor\": sign([i32, i32], [i32]),\n  \"i32.shl\": sign([i32, i32], [i32]),\n  \"i32.shr_s\": sign([i32, i32], [i32]),\n  \"i32.shr_u\": sign([i32, i32], [i32]),\n  \"i32.rotl\": sign([i32, i32], [i32]),\n  \"i32.rotr\": sign([i32, i32], [i32]),\n  \"i64.clz\": sign([i64], [i64]),\n  \"i64.ctz\": sign([i64], [i64]),\n  \"i64.popcnt\": sign([i64], [i64]),\n  \"i64.add\": sign([i64, i64], [i64]),\n  \"i64.sub\": sign([i64, i64], [i64]),\n  \"i64.mul\": sign([i64, i64], [i64]),\n  \"i64.div_s\": sign([i64, i64], [i64]),\n  \"i64.div_u\": sign([i64, i64], [i64]),\n  \"i64.rem_s\": sign([i64, i64], [i64]),\n  \"i64.rem_u\": sign([i64, i64], [i64]),\n  \"i64.and\": sign([i64, i64], [i64]),\n  \"i64.or\": sign([i64, i64], [i64]),\n  \"i64.xor\": sign([i64, i64], [i64]),\n  \"i64.shl\": sign([i64, i64], [i64]),\n  \"i64.shr_s\": sign([i64, i64], [i64]),\n  \"i64.shr_u\": sign([i64, i64], [i64]),\n  \"i64.rotl\": sign([i64, i64], [i64]),\n  \"i64.rotr\": sign([i64, i64], [i64]),\n  \"f32.abs\": sign([f32], [f32]),\n  \"f32.neg\": sign([f32], [f32]),\n  \"f32.ceil\": sign([f32], [f32]),\n  \"f32.floor\": sign([f32], [f32]),\n  \"f32.trunc\": sign([f32], [f32]),\n  \"f32.nearest\": sign([f32], [f32]),\n  \"f32.sqrt\": sign([f32], [f32]),\n  \"f32.add\": sign([f32, f32], [f32]),\n  \"f32.sub\": sign([f32, f32], [f32]),\n  \"f32.mul\": sign([f32, f32], [f32]),\n  \"f32.div\": sign([f32, f32], [f32]),\n  \"f32.min\": sign([f32, f32], [f32]),\n  \"f32.max\": sign([f32, f32], [f32]),\n  \"f32.copysign\": sign([f32, f32], [f32]),\n  \"f64.abs\": sign([f64], [f64]),\n  \"f64.neg\": sign([f64], [f64]),\n  \"f64.ceil\": sign([f64], [f64]),\n  \"f64.floor\": sign([f64], [f64]),\n  \"f64.trunc\": sign([f64], [f64]),\n  \"f64.nearest\": sign([f64], [f64]),\n  \"f64.sqrt\": sign([f64], [f64]),\n  \"f64.add\": sign([f64, f64], [f64]),\n  \"f64.sub\": sign([f64, f64], [f64]),\n  \"f64.mul\": sign([f64, f64], [f64]),\n  \"f64.div\": sign([f64, f64], [f64]),\n  \"f64.min\": sign([f64, f64], [f64]),\n  \"f64.max\": sign([f64, f64], [f64]),\n  \"f64.copysign\": sign([f64, f64], [f64]),\n  \"i32.wrap/i64\": sign([i64], [i32]),\n  \"i32.trunc_s/f32\": sign([f32], [i32]),\n  \"i32.trunc_u/f32\": sign([f32], [i32]),\n  \"i32.trunc_s/f64\": sign([f32], [i32]),\n  \"i32.trunc_u/f64\": sign([f64], [i32]),\n  \"i64.extend_s/i32\": sign([i32], [i64]),\n  \"i64.extend_u/i32\": sign([i32], [i64]),\n  \"i64.trunc_s/f32\": sign([f32], [i64]),\n  \"i64.trunc_u/f32\": sign([f32], [i64]),\n  \"i64.trunc_s/f64\": sign([f64], [i64]),\n  \"i64.trunc_u/f64\": sign([f64], [i64]),\n  \"f32.convert_s/i32\": sign([i32], [f32]),\n  \"f32.convert_u/i32\": sign([i32], [f32]),\n  \"f32.convert_s/i64\": sign([i64], [f32]),\n  \"f32.convert_u/i64\": sign([i64], [f32]),\n  \"f32.demote/f64\": sign([f64], [f32]),\n  \"f64.convert_s/i32\": sign([i32], [f64]),\n  \"f64.convert_u/i32\": sign([i32], [f64]),\n  \"f64.convert_s/i64\": sign([i64], [f64]),\n  \"f64.convert_u/i64\": sign([i64], [f64]),\n  \"f64.promote/f32\": sign([f32], [f64]),\n  \"i32.reinterpret/f32\": sign([f32], [i32]),\n  \"i64.reinterpret/f64\": sign([f64], [i64]),\n  \"f32.reinterpret/i32\": sign([i32], [f32]),\n  \"f64.reinterpret/i64\": sign([i64], [f64])\n};\nexport var signatures = Object.assign({}, controlInstructions, parametricInstructions, variableInstructions, memoryInstructions, numericInstructions);","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { isSignature, isNumberLiteral } from \"../../nodes.js\";\nexport function moduleContextFromModuleAST(m) {\n  var moduleContext = new ModuleContext();\n\n  if (!(m.type === \"Module\")) {\n    throw new Error('m.type === \"Module\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  m.fields.forEach(function (field) {\n    switch (field.type) {\n      case \"Start\":\n        {\n          moduleContext.setStart(field.index);\n          break;\n        }\n\n      case \"TypeInstruction\":\n        {\n          moduleContext.addType(field);\n          break;\n        }\n\n      case \"Func\":\n        {\n          moduleContext.addFunction(field);\n          break;\n        }\n\n      case \"Global\":\n        {\n          moduleContext.defineGlobal(field);\n          break;\n        }\n\n      case \"ModuleImport\":\n        {\n          switch (field.descr.type) {\n            case \"GlobalType\":\n              {\n                moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);\n                break;\n              }\n\n            case \"Memory\":\n              {\n                moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);\n                break;\n              }\n\n            case \"FuncImportDescr\":\n              {\n                moduleContext.importFunction(field.descr);\n                break;\n              }\n\n            case \"Table\":\n              {\n                // FIXME(sven): not implemented yet\n                break;\n              }\n\n            default:\n              throw new Error(\"Unsupported ModuleImport of type \" + JSON.stringify(field.descr.type));\n          }\n\n          break;\n        }\n\n      case \"Memory\":\n        {\n          moduleContext.addMemory(field.limits.min, field.limits.max);\n          break;\n        }\n    }\n  });\n  return moduleContext;\n}\n/**\n * Module context for type checking\n */\n\nexport var ModuleContext = /*#__PURE__*/function () {\n  function ModuleContext() {\n    _classCallCheck(this, ModuleContext);\n\n    this.funcs = [];\n    this.funcsOffsetByIdentifier = [];\n    this.types = [];\n    this.globals = [];\n    this.globalsOffsetByIdentifier = [];\n    this.mems = []; // Current stack frame\n\n    this.locals = [];\n    this.labels = [];\n    this[\"return\"] = [];\n    this.debugName = \"unknown\";\n    this.start = null;\n  }\n  /**\n   * Set start segment\n   */\n\n\n  _createClass(ModuleContext, [{\n    key: \"setStart\",\n    value: function setStart(index) {\n      this.start = index.value;\n    }\n    /**\n     * Get start function\n     */\n\n  }, {\n    key: \"getStart\",\n    value: function getStart() {\n      return this.start;\n    }\n    /**\n     * Reset the active stack frame\n     */\n\n  }, {\n    key: \"newContext\",\n    value: function newContext(debugName, expectedResult) {\n      this.locals = [];\n      this.labels = [expectedResult];\n      this[\"return\"] = expectedResult;\n      this.debugName = debugName;\n    }\n    /**\n     * Functions\n     */\n\n  }, {\n    key: \"addFunction\",\n    value: function addFunction(func) {\n      /* eslint-disable */\n      // $FlowIgnore\n      var _ref = func.signature || {},\n          _ref$params = _ref.params,\n          args = _ref$params === void 0 ? [] : _ref$params,\n          _ref$results = _ref.results,\n          result = _ref$results === void 0 ? [] : _ref$results;\n      /* eslint-enable */\n\n\n      args = args.map(function (arg) {\n        return arg.valtype;\n      });\n      this.funcs.push({\n        args: args,\n        result: result\n      });\n\n      if (typeof func.name !== \"undefined\") {\n        // $FlowIgnore\n        this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"importFunction\",\n    value: function importFunction(funcimport) {\n      if (isSignature(funcimport.signature)) {\n        // eslint-disable-next-line prefer-const\n        var _funcimport$signature = funcimport.signature,\n            args = _funcimport$signature.params,\n            result = _funcimport$signature.results;\n        args = args.map(function (arg) {\n          return arg.valtype;\n        });\n        this.funcs.push({\n          args: args,\n          result: result\n        });\n      } else {\n        if (!isNumberLiteral(funcimport.signature)) {\n          throw new Error('isNumberLiteral(funcimport.signature)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var typeId = funcimport.signature.value;\n\n        if (!this.hasType(typeId)) {\n          throw new Error('this.hasType(typeId)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var signature = this.getType(typeId);\n        this.funcs.push({\n          args: signature.params.map(function (arg) {\n            return arg.valtype;\n          }),\n          result: signature.results\n        });\n      }\n\n      if (typeof funcimport.id !== \"undefined\") {\n        // imports are first, we can assume their index in the array\n        this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(index) {\n      return typeof this.getFunction(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(index) {\n      if (typeof index !== \"number\") {\n        throw new Error(\"getFunction only supported for number index\");\n      }\n\n      return this.funcs[index];\n    }\n  }, {\n    key: \"getFunctionOffsetByIdentifier\",\n    value: function getFunctionOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      return this.funcsOffsetByIdentifier[name];\n    }\n    /**\n     * Labels\n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(result) {\n      this.labels.unshift(result);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(index) {\n      return this.labels.length > index && index >= 0;\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(index) {\n      return this.labels[index];\n    }\n  }, {\n    key: \"popLabel\",\n    value: function popLabel() {\n      this.labels.shift();\n    }\n    /**\n     * Locals\n     */\n\n  }, {\n    key: \"hasLocal\",\n    value: function hasLocal(index) {\n      return typeof this.getLocal(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(index) {\n      return this.locals[index];\n    }\n  }, {\n    key: \"addLocal\",\n    value: function addLocal(type) {\n      this.locals.push(type);\n    }\n    /**\n     * Types\n     */\n\n  }, {\n    key: \"addType\",\n    value: function addType(type) {\n      if (!(type.functype.type === \"Signature\")) {\n        throw new Error('type.functype.type === \"Signature\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      this.types.push(type.functype);\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(index) {\n      return this.types[index] !== undefined;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(index) {\n      return this.types[index];\n    }\n    /**\n     * Globals\n     */\n\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(index) {\n      return this.globals.length > index && index >= 0;\n    }\n  }, {\n    key: \"getGlobal\",\n    value: function getGlobal(index) {\n      return this.globals[index].type;\n    }\n  }, {\n    key: \"getGlobalOffsetByIdentifier\",\n    value: function getGlobalOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      // $FlowIgnore\n      return this.globalsOffsetByIdentifier[name];\n    }\n  }, {\n    key: \"defineGlobal\",\n    value: function defineGlobal(global) {\n      var type = global.globalType.valtype;\n      var mutability = global.globalType.mutability;\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n\n      if (typeof global.name !== \"undefined\") {\n        // $FlowIgnore\n        this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1;\n      }\n    }\n  }, {\n    key: \"importGlobal\",\n    value: function importGlobal(type, mutability) {\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n    }\n  }, {\n    key: \"isMutableGlobal\",\n    value: function isMutableGlobal(index) {\n      return this.globals[index].mutability === \"var\";\n    }\n  }, {\n    key: \"isImmutableGlobal\",\n    value: function isImmutableGlobal(index) {\n      return this.globals[index].mutability === \"const\";\n    }\n    /**\n     * Memories\n     */\n\n  }, {\n    key: \"hasMemory\",\n    value: function hasMemory(index) {\n      return this.mems.length > index && index >= 0;\n    }\n  }, {\n    key: \"addMemory\",\n    value: function addMemory(min, max) {\n      this.mems.push({\n        min: min,\n        max: max\n      });\n    }\n  }, {\n    key: \"getMemory\",\n    value: function getMemory(index) {\n      return this.mems[index];\n    }\n  }]);\n\n  return ModuleContext;\n}();","import { createPath } from \"./node-path\";\nimport { unionTypesMap, nodeAndUnionTypes } from \"./nodes\"; // recursively walks the AST starting at the given node. The callback is invoked for\n// and object that has a 'type' property.\n\nfunction walk(context, callback) {\n  var stop = false;\n\n  function innerWalk(context, callback) {\n    if (stop) {\n      return;\n    }\n\n    var node = context.node;\n\n    if (node === undefined) {\n      console.warn(\"traversing with an empty context\");\n      return;\n    }\n\n    if (node._deleted === true) {\n      return;\n    }\n\n    var path = createPath(context);\n    callback(node.type, path);\n\n    if (path.shouldStop) {\n      stop = true;\n      return;\n    }\n\n    Object.keys(node).forEach(function (prop) {\n      var value = node[prop];\n\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      var valueAsArray = Array.isArray(value) ? value : [value];\n      valueAsArray.forEach(function (childNode) {\n        if (typeof childNode.type === \"string\") {\n          var childContext = {\n            node: childNode,\n            parentKey: prop,\n            parentPath: path,\n            shouldStop: false,\n            inList: Array.isArray(value)\n          };\n          innerWalk(childContext, callback);\n        }\n      });\n    });\n  }\n\n  innerWalk(context, callback);\n}\n\nvar noop = function noop() {};\n\nexport function traverse(node, visitors) {\n  var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  var after = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n  Object.keys(visitors).forEach(function (visitor) {\n    if (!nodeAndUnionTypes.includes(visitor)) {\n      throw new Error(\"Unexpected visitor \".concat(visitor));\n    }\n  });\n  var context = {\n    node: node,\n    inList: false,\n    shouldStop: false,\n    parentPath: null,\n    parentKey: null\n  };\n  walk(context, function (type, path) {\n    if (typeof visitors[type] === \"function\") {\n      before(type, path);\n      visitors[type](path);\n      after(type, path);\n    }\n\n    var unionTypes = unionTypesMap[type];\n\n    if (!unionTypes) {\n      throw new Error(\"Unexpected node type \".concat(type));\n    }\n\n    unionTypes.forEach(function (unionType) {\n      if (typeof visitors[unionType] === \"function\") {\n        before(unionType, path);\n        visitors[unionType](path);\n        after(unionType, path);\n      }\n    });\n  });\n}","function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { signatures } from \"./signatures\";\nimport { traverse } from \"./traverse\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nimport { getSectionForNode } from \"@webassemblyjs/helper-wasm-bytecode\";\nexport function isAnonymous(ident) {\n  return ident.raw === \"\";\n}\nexport function getSectionMetadata(ast, name) {\n  var section;\n  traverse(ast, {\n    SectionMetadata: function (_SectionMetadata) {\n      function SectionMetadata(_x) {\n        return _SectionMetadata.apply(this, arguments);\n      }\n\n      SectionMetadata.toString = function () {\n        return _SectionMetadata.toString();\n      };\n\n      return SectionMetadata;\n    }(function (_ref) {\n      var node = _ref.node;\n\n      if (node.section === name) {\n        section = node;\n      }\n    })\n  });\n  return section;\n}\nexport function getSectionMetadatas(ast, name) {\n  var sections = [];\n  traverse(ast, {\n    SectionMetadata: function (_SectionMetadata2) {\n      function SectionMetadata(_x2) {\n        return _SectionMetadata2.apply(this, arguments);\n      }\n\n      SectionMetadata.toString = function () {\n        return _SectionMetadata2.toString();\n      };\n\n      return SectionMetadata;\n    }(function (_ref2) {\n      var node = _ref2.node;\n\n      if (node.section === name) {\n        sections.push(node);\n      }\n    })\n  });\n  return sections;\n}\nexport function sortSectionMetadata(m) {\n  if (m.metadata == null) {\n    console.warn(\"sortSectionMetadata: no metadata to sort\");\n    return;\n  } // $FlowIgnore\n\n\n  m.metadata.sections.sort(function (a, b) {\n    var aId = constants.sections[a.section];\n    var bId = constants.sections[b.section];\n\n    if (typeof aId !== \"number\" || typeof bId !== \"number\") {\n      throw new Error(\"Section id not found\");\n    }\n\n    return aId - bId;\n  });\n}\nexport function orderedInsertNode(m, n) {\n  assertHasLoc(n);\n  var didInsert = false;\n\n  if (n.type === \"ModuleExport\") {\n    m.fields.push(n);\n    return;\n  }\n\n  m.fields = m.fields.reduce(function (acc, field) {\n    var fieldEndCol = Infinity;\n\n    if (field.loc != null) {\n      // $FlowIgnore\n      fieldEndCol = field.loc.end.column;\n    } // $FlowIgnore: assertHasLoc ensures that\n\n\n    if (didInsert === false && n.loc.start.column < fieldEndCol) {\n      didInsert = true;\n      acc.push(n);\n    }\n\n    acc.push(field);\n    return acc;\n  }, []); // Handles empty modules or n is the last element\n\n  if (didInsert === false) {\n    m.fields.push(n);\n  }\n}\nexport function assertHasLoc(n) {\n  if (n.loc == null || n.loc.start == null || n.loc.end == null) {\n    throw new Error(\"Internal failure: node (\".concat(JSON.stringify(n.type), \") has no location information\"));\n  }\n}\nexport function getEndOfSection(s) {\n  assertHasLoc(s.size);\n  return s.startOffset + s.size.value + (s.size.loc.end.column - s.size.loc.start.column);\n}\nexport function shiftLoc(node, delta) {\n  // $FlowIgnore\n  node.loc.start.column += delta; // $FlowIgnore\n\n  node.loc.end.column += delta;\n}\nexport function shiftSection(ast, node, delta) {\n  if (node.type !== \"SectionMetadata\") {\n    throw new Error(\"Can not shift node \" + JSON.stringify(node.type));\n  }\n\n  node.startOffset += delta;\n\n  if (_typeof(node.size.loc) === \"object\") {\n    shiftLoc(node.size, delta);\n  } // Custom sections doesn't have vectorOfSize\n\n\n  if (_typeof(node.vectorOfSize) === \"object\" && _typeof(node.vectorOfSize.loc) === \"object\") {\n    shiftLoc(node.vectorOfSize, delta);\n  }\n\n  var sectionName = node.section; // shift node locations within that section\n\n  traverse(ast, {\n    Node: function Node(_ref3) {\n      var node = _ref3.node;\n      var section = getSectionForNode(node);\n\n      if (section === sectionName && _typeof(node.loc) === \"object\") {\n        shiftLoc(node, delta);\n      }\n    }\n  });\n}\nexport function signatureForOpcode(object, name) {\n  var opcodeName = name;\n\n  if (object !== undefined && object !== \"\") {\n    opcodeName = object + \".\" + name;\n  }\n\n  var sign = signatures[opcodeName];\n\n  if (sign == undefined) {\n    // TODO: Uncomment this when br_table and others has been done\n    //throw new Error(\"Invalid opcode: \"+opcodeName);\n    return [object, object];\n  }\n\n  return sign[0];\n}\nexport function getUniqueNameGenerator() {\n  var inc = {};\n  return function () {\n    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n\n    if (!(prefix in inc)) {\n      inc[prefix] = 0;\n    } else {\n      inc[prefix] = inc[prefix] + 1;\n    }\n\n    return prefix + \"_\" + inc[prefix];\n  };\n}\nexport function getStartByteOffset(n) {\n  // $FlowIgnore\n  if (typeof n.loc === \"undefined\" || typeof n.loc.start === \"undefined\") {\n    throw new Error( // $FlowIgnore\n    \"Can not get byte offset without loc informations, node: \" + String(n.id));\n  }\n\n  return n.loc.start.column;\n}\nexport function getEndByteOffset(n) {\n  // $FlowIgnore\n  if (typeof n.loc === \"undefined\" || typeof n.loc.end === \"undefined\") {\n    throw new Error(\"Can not get byte offset without loc informations, node: \" + n.type);\n  }\n\n  return n.loc.end.column;\n}\nexport function getFunctionBeginingByteOffset(n) {\n  if (!(n.body.length > 0)) {\n    throw new Error('n.body.length > 0' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var _n$body = _slicedToArray(n.body, 1),\n      firstInstruction = _n$body[0];\n\n  return getStartByteOffset(firstInstruction);\n}\nexport function getEndBlockByteOffset(n) {\n  // $FlowIgnore\n  if (!(n.instr.length > 0 || n.body.length > 0)) {\n    throw new Error('n.instr.length > 0 || n.body.length > 0' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var lastInstruction;\n\n  if (n.instr) {\n    // $FlowIgnore\n    lastInstruction = n.instr[n.instr.length - 1];\n  }\n\n  if (n.body) {\n    // $FlowIgnore\n    lastInstruction = n.body[n.body.length - 1];\n  }\n\n  if (!(_typeof(lastInstruction) === \"object\")) {\n    throw new Error('typeof lastInstruction === \"object\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  return getStartByteOffset(lastInstruction);\n}\nexport function getStartBlockByteOffset(n) {\n  // $FlowIgnore\n  if (!(n.instr.length > 0 || n.body.length > 0)) {\n    throw new Error('n.instr.length > 0 || n.body.length > 0' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  var fistInstruction;\n\n  if (n.instr) {\n    // $FlowIgnore\n    var _n$instr = _slicedToArray(n.instr, 1);\n\n    fistInstruction = _n$instr[0];\n  }\n\n  if (n.body) {\n    // $FlowIgnore\n    var _n$body2 = _slicedToArray(n.body, 1);\n\n    fistInstruction = _n$body2[0];\n  }\n\n  if (!(_typeof(fistInstruction) === \"object\")) {\n    throw new Error('typeof fistInstruction === \"object\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  return getStartByteOffset(fistInstruction);\n}","export default function parse(input) {\n  input = input.toUpperCase();\n  var splitIndex = input.indexOf(\"P\");\n  var mantissa, exponent;\n\n  if (splitIndex !== -1) {\n    mantissa = input.substring(0, splitIndex);\n    exponent = parseInt(input.substring(splitIndex + 1));\n  } else {\n    mantissa = input;\n    exponent = 0;\n  }\n\n  var dotIndex = mantissa.indexOf(\".\");\n\n  if (dotIndex !== -1) {\n    var integerPart = parseInt(mantissa.substring(0, dotIndex), 16);\n    var sign = Math.sign(integerPart);\n    integerPart = sign * integerPart;\n    var fractionLength = mantissa.length - dotIndex - 1;\n    var fractionalPart = parseInt(mantissa.substring(dotIndex + 1), 16);\n    var fraction = fractionLength > 0 ? fractionalPart / Math.pow(16, fractionLength) : 0;\n\n    if (sign === 0) {\n      if (fraction === 0) {\n        mantissa = sign;\n      } else {\n        if (Object.is(sign, -0)) {\n          mantissa = -fraction;\n        } else {\n          mantissa = fraction;\n        }\n      }\n    } else {\n      mantissa = sign * (integerPart + fraction);\n    }\n  } else {\n    mantissa = parseInt(mantissa, 16);\n  }\n\n  return mantissa * (splitIndex !== -1 ? Math.pow(2, exponent) : 1);\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nexport var RuntimeError = /*#__PURE__*/function (_Error) {\n  _inherits(RuntimeError, _Error);\n\n  var _super = _createSuper(RuntimeError);\n\n  function RuntimeError() {\n    _classCallCheck(this, RuntimeError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return RuntimeError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var CompileError = /*#__PURE__*/function (_Error2) {\n  _inherits(CompileError, _Error2);\n\n  var _super2 = _createSuper(CompileError);\n\n  function CompileError() {\n    _classCallCheck(this, CompileError);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return CompileError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var LinkError = /*#__PURE__*/function (_Error3) {\n  _inherits(LinkError, _Error3);\n\n  var _super3 = _createSuper(LinkError);\n\n  function LinkError() {\n    _classCallCheck(this, LinkError);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return LinkError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));","import Long from \"@xtuc/long\";\nimport parseHexFloat from \"@webassemblyjs/floating-point-hex-parser\";\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nexport function parse32F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x400000);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse64F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x8000000000000);\n  }\n\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse32I(sourceString) {\n  var value = 0;\n\n  if (isHexLiteral(sourceString)) {\n    value = ~~parseInt(sourceString, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    value = parseInt(sourceString, 10);\n  }\n\n  return value;\n}\nexport function parseU32(sourceString) {\n  var value = parse32I(sourceString);\n\n  if (value < 0) {\n    throw new CompileError(\"Illegal value for u32: \" + sourceString);\n  }\n\n  return value;\n}\nexport function parse64I(sourceString) {\n  // $FlowIgnore\n  var _long;\n\n  if (isHexLiteral(sourceString)) {\n    _long = Long.fromString(sourceString, false, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    _long = Long.fromString(sourceString);\n  }\n\n  return {\n    high: _long.high,\n    low: _long.low\n  };\n}\nvar NAN_WORD = /^\\+?-?nan/;\nvar INF_WORD = /^\\+?-?inf/;\nexport function isInfLiteral(sourceString) {\n  return INF_WORD.test(sourceString.toLowerCase());\n}\nexport function isNanLiteral(sourceString) {\n  return NAN_WORD.test(sourceString.toLowerCase());\n}\n\nfunction isDecimalExponentLiteral(sourceString) {\n  return !isHexLiteral(sourceString) && sourceString.toUpperCase().includes(\"E\");\n}\n\nfunction isHexLiteral(sourceString) {\n  return sourceString.substring(0, 2).toUpperCase() === \"0X\" || sourceString.substring(0, 3).toUpperCase() === \"-0X\";\n}","var illegalop = \"illegal\";\nvar magicModuleHeader = [0x00, 0x61, 0x73, 0x6d];\nvar moduleVersion = [0x01, 0x00, 0x00, 0x00];\n\nfunction invertMap(obj) {\n  var keyModifierFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (k) {\n    return k;\n  };\n  var result = {};\n  var keys = Object.keys(obj);\n\n  for (var i = 0, length = keys.length; i < length; i++) {\n    result[keyModifierFn(obj[keys[i]])] = keys[i];\n  }\n\n  return result;\n}\n\nfunction createSymbolObject(name\n/*: string */\n, object\n/*: string */\n)\n/*: Symbol*/\n{\n  var numberOfArgs\n  /*: number*/\n  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return {\n    name: name,\n    object: object,\n    numberOfArgs: numberOfArgs\n  };\n}\n\nfunction createSymbol(name\n/*: string */\n)\n/*: Symbol*/\n{\n  var numberOfArgs\n  /*: number*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return {\n    name: name,\n    numberOfArgs: numberOfArgs\n  };\n}\n\nvar types = {\n  func: 0x60,\n  result: 0x40\n};\nvar exportTypes = {\n  0x00: \"Func\",\n  0x01: \"Table\",\n  0x02: \"Memory\",\n  0x03: \"Global\"\n};\nvar exportTypesByName = invertMap(exportTypes);\nvar valtypes = {\n  // numtype\n  0x7f: \"i32\",\n  0x7e: \"i64\",\n  0x7d: \"f32\",\n  0x7c: \"f64\",\n  // vectype\n  0x7b: \"v128\",\n  // reftype\n  0x70: \"anyfunc\",\n  0x6f: \"externref\"\n};\nvar valtypesByString = invertMap(valtypes);\nvar tableTypes = {\n  0x70: \"anyfunc\",\n  0x6f: \"externref\"\n};\nvar blockTypes = Object.assign({}, valtypes, {\n  // https://webassembly.github.io/spec/core/binary/types.html#binary-blocktype\n  0x40: null,\n  // https://webassembly.github.io/spec/core/binary/types.html#binary-valtype\n  0x7f: \"i32\",\n  0x7e: \"i64\",\n  0x7d: \"f32\",\n  0x7c: \"f64\"\n});\nvar globalTypes = {\n  0x00: \"const\",\n  0x01: \"var\"\n};\nvar globalTypesByString = invertMap(globalTypes);\nvar importTypes = {\n  0x00: \"func\",\n  0x01: \"table\",\n  0x02: \"memory\",\n  0x03: \"global\"\n};\nvar sections = {\n  custom: 0,\n  type: 1,\n  \"import\": 2,\n  func: 3,\n  table: 4,\n  memory: 5,\n  global: 6,\n  \"export\": 7,\n  start: 8,\n  element: 9,\n  code: 10,\n  data: 11\n};\nvar symbolsByByte = {\n  0x00: createSymbol(\"unreachable\"),\n  0x01: createSymbol(\"nop\"),\n  0x02: createSymbol(\"block\"),\n  0x03: createSymbol(\"loop\"),\n  0x04: createSymbol(\"if\"),\n  0x05: createSymbol(\"else\"),\n  0x06: illegalop,\n  0x07: illegalop,\n  0x08: illegalop,\n  0x09: illegalop,\n  0x0a: illegalop,\n  0x0b: createSymbol(\"end\"),\n  0x0c: createSymbol(\"br\", 1),\n  0x0d: createSymbol(\"br_if\", 1),\n  0x0e: createSymbol(\"br_table\"),\n  0x0f: createSymbol(\"return\"),\n  0x10: createSymbol(\"call\", 1),\n  0x11: createSymbol(\"call_indirect\", 2),\n  0x12: illegalop,\n  0x13: illegalop,\n  0x14: illegalop,\n  0x15: illegalop,\n  0x16: illegalop,\n  0x17: illegalop,\n  0x18: illegalop,\n  0x19: illegalop,\n  0x1a: createSymbol(\"drop\"),\n  0x1b: createSymbol(\"select\"),\n  0x1c: illegalop,\n  0x1d: illegalop,\n  0x1e: illegalop,\n  0x1f: illegalop,\n  0x20: createSymbol(\"get_local\", 1),\n  0x21: createSymbol(\"set_local\", 1),\n  0x22: createSymbol(\"tee_local\", 1),\n  0x23: createSymbol(\"get_global\", 1),\n  0x24: createSymbol(\"set_global\", 1),\n  0x25: createSymbol(\"table.get\", 1),\n  0x26: createSymbol(\"table.set\", 1),\n  0x27: illegalop,\n  0x28: createSymbolObject(\"load\", \"u32\", 1),\n  0x29: createSymbolObject(\"load\", \"u64\", 1),\n  0x2a: createSymbolObject(\"load\", \"f32\", 1),\n  0x2b: createSymbolObject(\"load\", \"f64\", 1),\n  0x2c: createSymbolObject(\"load8_s\", \"u32\", 1),\n  0x2d: createSymbolObject(\"load8_u\", \"u32\", 1),\n  0x2e: createSymbolObject(\"load16_s\", \"u32\", 1),\n  0x2f: createSymbolObject(\"load16_u\", \"u32\", 1),\n  0x30: createSymbolObject(\"load8_s\", \"u64\", 1),\n  0x31: createSymbolObject(\"load8_u\", \"u64\", 1),\n  0x32: createSymbolObject(\"load16_s\", \"u64\", 1),\n  0x33: createSymbolObject(\"load16_u\", \"u64\", 1),\n  0x34: createSymbolObject(\"load32_s\", \"u64\", 1),\n  0x35: createSymbolObject(\"load32_u\", \"u64\", 1),\n  0x36: createSymbolObject(\"store\", \"u32\", 1),\n  0x37: createSymbolObject(\"store\", \"u64\", 1),\n  0x38: createSymbolObject(\"store\", \"f32\", 1),\n  0x39: createSymbolObject(\"store\", \"f64\", 1),\n  0x3a: createSymbolObject(\"store8\", \"u32\", 1),\n  0x3b: createSymbolObject(\"store16\", \"u32\", 1),\n  0x3c: createSymbolObject(\"store8\", \"u64\", 1),\n  0x3d: createSymbolObject(\"store16\", \"u64\", 1),\n  0x3e: createSymbolObject(\"store32\", \"u64\", 1),\n  0x3f: createSymbolObject(\"current_memory\"),\n  0x40: createSymbolObject(\"grow_memory\"),\n  0x41: createSymbolObject(\"const\", \"i32\", 1),\n  0x42: createSymbolObject(\"const\", \"i64\", 1),\n  0x43: createSymbolObject(\"const\", \"f32\", 1),\n  0x44: createSymbolObject(\"const\", \"f64\", 1),\n  0x45: createSymbolObject(\"eqz\", \"i32\"),\n  0x46: createSymbolObject(\"eq\", \"i32\"),\n  0x47: createSymbolObject(\"ne\", \"i32\"),\n  0x48: createSymbolObject(\"lt_s\", \"i32\"),\n  0x49: createSymbolObject(\"lt_u\", \"i32\"),\n  0x4a: createSymbolObject(\"gt_s\", \"i32\"),\n  0x4b: createSymbolObject(\"gt_u\", \"i32\"),\n  0x4c: createSymbolObject(\"le_s\", \"i32\"),\n  0x4d: createSymbolObject(\"le_u\", \"i32\"),\n  0x4e: createSymbolObject(\"ge_s\", \"i32\"),\n  0x4f: createSymbolObject(\"ge_u\", \"i32\"),\n  0x50: createSymbolObject(\"eqz\", \"i64\"),\n  0x51: createSymbolObject(\"eq\", \"i64\"),\n  0x52: createSymbolObject(\"ne\", \"i64\"),\n  0x53: createSymbolObject(\"lt_s\", \"i64\"),\n  0x54: createSymbolObject(\"lt_u\", \"i64\"),\n  0x55: createSymbolObject(\"gt_s\", \"i64\"),\n  0x56: createSymbolObject(\"gt_u\", \"i64\"),\n  0x57: createSymbolObject(\"le_s\", \"i64\"),\n  0x58: createSymbolObject(\"le_u\", \"i64\"),\n  0x59: createSymbolObject(\"ge_s\", \"i64\"),\n  0x5a: createSymbolObject(\"ge_u\", \"i64\"),\n  0x5b: createSymbolObject(\"eq\", \"f32\"),\n  0x5c: createSymbolObject(\"ne\", \"f32\"),\n  0x5d: createSymbolObject(\"lt\", \"f32\"),\n  0x5e: createSymbolObject(\"gt\", \"f32\"),\n  0x5f: createSymbolObject(\"le\", \"f32\"),\n  0x60: createSymbolObject(\"ge\", \"f32\"),\n  0x61: createSymbolObject(\"eq\", \"f64\"),\n  0x62: createSymbolObject(\"ne\", \"f64\"),\n  0x63: createSymbolObject(\"lt\", \"f64\"),\n  0x64: createSymbolObject(\"gt\", \"f64\"),\n  0x65: createSymbolObject(\"le\", \"f64\"),\n  0x66: createSymbolObject(\"ge\", \"f64\"),\n  0x67: createSymbolObject(\"clz\", \"i32\"),\n  0x68: createSymbolObject(\"ctz\", \"i32\"),\n  0x69: createSymbolObject(\"popcnt\", \"i32\"),\n  0x6a: createSymbolObject(\"add\", \"i32\"),\n  0x6b: createSymbolObject(\"sub\", \"i32\"),\n  0x6c: createSymbolObject(\"mul\", \"i32\"),\n  0x6d: createSymbolObject(\"div_s\", \"i32\"),\n  0x6e: createSymbolObject(\"div_u\", \"i32\"),\n  0x6f: createSymbolObject(\"rem_s\", \"i32\"),\n  0x70: createSymbolObject(\"rem_u\", \"i32\"),\n  0x71: createSymbolObject(\"and\", \"i32\"),\n  0x72: createSymbolObject(\"or\", \"i32\"),\n  0x73: createSymbolObject(\"xor\", \"i32\"),\n  0x74: createSymbolObject(\"shl\", \"i32\"),\n  0x75: createSymbolObject(\"shr_s\", \"i32\"),\n  0x76: createSymbolObject(\"shr_u\", \"i32\"),\n  0x77: createSymbolObject(\"rotl\", \"i32\"),\n  0x78: createSymbolObject(\"rotr\", \"i32\"),\n  0x79: createSymbolObject(\"clz\", \"i64\"),\n  0x7a: createSymbolObject(\"ctz\", \"i64\"),\n  0x7b: createSymbolObject(\"popcnt\", \"i64\"),\n  0x7c: createSymbolObject(\"add\", \"i64\"),\n  0x7d: createSymbolObject(\"sub\", \"i64\"),\n  0x7e: createSymbolObject(\"mul\", \"i64\"),\n  0x7f: createSymbolObject(\"div_s\", \"i64\"),\n  0x80: createSymbolObject(\"div_u\", \"i64\"),\n  0x81: createSymbolObject(\"rem_s\", \"i64\"),\n  0x82: createSymbolObject(\"rem_u\", \"i64\"),\n  0x83: createSymbolObject(\"and\", \"i64\"),\n  0x84: createSymbolObject(\"or\", \"i64\"),\n  0x85: createSymbolObject(\"xor\", \"i64\"),\n  0x86: createSymbolObject(\"shl\", \"i64\"),\n  0x87: createSymbolObject(\"shr_s\", \"i64\"),\n  0x88: createSymbolObject(\"shr_u\", \"i64\"),\n  0x89: createSymbolObject(\"rotl\", \"i64\"),\n  0x8a: createSymbolObject(\"rotr\", \"i64\"),\n  0x8b: createSymbolObject(\"abs\", \"f32\"),\n  0x8c: createSymbolObject(\"neg\", \"f32\"),\n  0x8d: createSymbolObject(\"ceil\", \"f32\"),\n  0x8e: createSymbolObject(\"floor\", \"f32\"),\n  0x8f: createSymbolObject(\"trunc\", \"f32\"),\n  0x90: createSymbolObject(\"nearest\", \"f32\"),\n  0x91: createSymbolObject(\"sqrt\", \"f32\"),\n  0x92: createSymbolObject(\"add\", \"f32\"),\n  0x93: createSymbolObject(\"sub\", \"f32\"),\n  0x94: createSymbolObject(\"mul\", \"f32\"),\n  0x95: createSymbolObject(\"div\", \"f32\"),\n  0x96: createSymbolObject(\"min\", \"f32\"),\n  0x97: createSymbolObject(\"max\", \"f32\"),\n  0x98: createSymbolObject(\"copysign\", \"f32\"),\n  0x99: createSymbolObject(\"abs\", \"f64\"),\n  0x9a: createSymbolObject(\"neg\", \"f64\"),\n  0x9b: createSymbolObject(\"ceil\", \"f64\"),\n  0x9c: createSymbolObject(\"floor\", \"f64\"),\n  0x9d: createSymbolObject(\"trunc\", \"f64\"),\n  0x9e: createSymbolObject(\"nearest\", \"f64\"),\n  0x9f: createSymbolObject(\"sqrt\", \"f64\"),\n  0xa0: createSymbolObject(\"add\", \"f64\"),\n  0xa1: createSymbolObject(\"sub\", \"f64\"),\n  0xa2: createSymbolObject(\"mul\", \"f64\"),\n  0xa3: createSymbolObject(\"div\", \"f64\"),\n  0xa4: createSymbolObject(\"min\", \"f64\"),\n  0xa5: createSymbolObject(\"max\", \"f64\"),\n  0xa6: createSymbolObject(\"copysign\", \"f64\"),\n  0xa7: createSymbolObject(\"wrap/i64\", \"i32\"),\n  0xa8: createSymbolObject(\"trunc_s/f32\", \"i32\"),\n  0xa9: createSymbolObject(\"trunc_u/f32\", \"i32\"),\n  0xaa: createSymbolObject(\"trunc_s/f64\", \"i32\"),\n  0xab: createSymbolObject(\"trunc_u/f64\", \"i32\"),\n  0xac: createSymbolObject(\"extend_s/i32\", \"i64\"),\n  0xad: createSymbolObject(\"extend_u/i32\", \"i64\"),\n  0xae: createSymbolObject(\"trunc_s/f32\", \"i64\"),\n  0xaf: createSymbolObject(\"trunc_u/f32\", \"i64\"),\n  0xb0: createSymbolObject(\"trunc_s/f64\", \"i64\"),\n  0xb1: createSymbolObject(\"trunc_u/f64\", \"i64\"),\n  0xb2: createSymbolObject(\"convert_s/i32\", \"f32\"),\n  0xb3: createSymbolObject(\"convert_u/i32\", \"f32\"),\n  0xb4: createSymbolObject(\"convert_s/i64\", \"f32\"),\n  0xb5: createSymbolObject(\"convert_u/i64\", \"f32\"),\n  0xb6: createSymbolObject(\"demote/f64\", \"f32\"),\n  0xb7: createSymbolObject(\"convert_s/i32\", \"f64\"),\n  0xb8: createSymbolObject(\"convert_u/i32\", \"f64\"),\n  0xb9: createSymbolObject(\"convert_s/i64\", \"f64\"),\n  0xba: createSymbolObject(\"convert_u/i64\", \"f64\"),\n  0xbb: createSymbolObject(\"promote/f32\", \"f64\"),\n  0xbc: createSymbolObject(\"reinterpret/f32\", \"i32\"),\n  0xbd: createSymbolObject(\"reinterpret/f64\", \"i64\"),\n  0xbe: createSymbolObject(\"reinterpret/i32\", \"f32\"),\n  0xbf: createSymbolObject(\"reinterpret/i64\", \"f64\"),\n  0xc0: createSymbolObject(\"extend8_s\", \"i32\"),\n  0xc1: createSymbolObject(\"extend16_s\", \"i32\"),\n  0xc2: createSymbolObject(\"extend8_s\", \"i64\"),\n  0xc3: createSymbolObject(\"extend16_s\", \"i64\"),\n  0xc4: createSymbolObject(\"extend32_s\", \"i64\"),\n  0xd0: createSymbol(\"ref.null\"),\n  0xd1: createSymbol(\"ref.is_null\"),\n  0xd2: createSymbol(\"ref.func\", 1),\n  0xfc0a: createSymbol(\"memory.copy\"),\n  0xfc0b: createSymbol(\"memory.fill\"),\n  // Table instructions\n  // https://webassembly.github.io/spec/core/binary/instructions.html#table-instructions\n  0xfc0c: createSymbol(\"table.init\", 2),\n  0xfc0d: createSymbol(\"elem.drop\", 1),\n  0xfc0e: createSymbol(\"table.copy\", 2),\n  0xfc0f: createSymbol(\"table.grow\", 1),\n  0xfc10: createSymbol(\"table.size\", 1),\n  0xfc11: createSymbol(\"table.fill\", 1),\n  // Atomic Memory Instructions\n  0xfe00: createSymbol(\"memory.atomic.notify\", 1),\n  0xfe01: createSymbol(\"memory.atomic.wait32\", 1),\n  0xfe02: createSymbol(\"memory.atomic.wait64\", 1),\n  0xfe10: createSymbolObject(\"atomic.load\", \"i32\", 1),\n  0xfe11: createSymbolObject(\"atomic.load\", \"i64\", 1),\n  0xfe12: createSymbolObject(\"atomic.load8_u\", \"i32\", 1),\n  0xfe13: createSymbolObject(\"atomic.load16_u\", \"i32\", 1),\n  0xfe14: createSymbolObject(\"atomic.load8_u\", \"i64\", 1),\n  0xfe15: createSymbolObject(\"atomic.load16_u\", \"i64\", 1),\n  0xfe16: createSymbolObject(\"atomic.load32_u\", \"i64\", 1),\n  0xfe17: createSymbolObject(\"atomic.store\", \"i32\", 1),\n  0xfe18: createSymbolObject(\"atomic.store\", \"i64\", 1),\n  0xfe19: createSymbolObject(\"atomic.store8_u\", \"i32\", 1),\n  0xfe1a: createSymbolObject(\"atomic.store16_u\", \"i32\", 1),\n  0xfe1b: createSymbolObject(\"atomic.store8_u\", \"i64\", 1),\n  0xfe1c: createSymbolObject(\"atomic.store16_u\", \"i64\", 1),\n  0xfe1d: createSymbolObject(\"atomic.store32_u\", \"i64\", 1),\n  0xfe1e: createSymbolObject(\"atomic.rmw.add\", \"i32\", 1),\n  0xfe1f: createSymbolObject(\"atomic.rmw.add\", \"i64\", 1),\n  0xfe20: createSymbolObject(\"atomic.rmw8_u.add_u\", \"i32\", 1),\n  0xfe21: createSymbolObject(\"atomic.rmw16_u.add_u\", \"i32\", 1),\n  0xfe22: createSymbolObject(\"atomic.rmw8_u.add_u\", \"i64\", 1),\n  0xfe23: createSymbolObject(\"atomic.rmw16_u.add_u\", \"i64\", 1),\n  0xfe24: createSymbolObject(\"atomic.rmw32_u.add_u\", \"i64\", 1),\n  0xfe25: createSymbolObject(\"atomic.rmw.sub\", \"i32\", 1),\n  0xfe26: createSymbolObject(\"atomic.rmw.sub\", \"i64\", 1),\n  0xfe27: createSymbolObject(\"atomic.rmw8_u.sub_u\", \"i32\", 1),\n  0xfe28: createSymbolObject(\"atomic.rmw16_u.sub_u\", \"i32\", 1),\n  0xfe29: createSymbolObject(\"atomic.rmw8_u.sub_u\", \"i64\", 1),\n  0xfe2a: createSymbolObject(\"atomic.rmw16_u.sub_u\", \"i64\", 1),\n  0xfe2b: createSymbolObject(\"atomic.rmw32_u.sub_u\", \"i64\", 1),\n  0xfe2c: createSymbolObject(\"atomic.rmw.and\", \"i32\", 1),\n  0xfe2d: createSymbolObject(\"atomic.rmw.and\", \"i64\", 1),\n  0xfe2e: createSymbolObject(\"atomic.rmw8_u.and_u\", \"i32\", 1),\n  0xfe2f: createSymbolObject(\"atomic.rmw16_u.and_u\", \"i32\", 1),\n  0xfe30: createSymbolObject(\"atomic.rmw8_u.and_u\", \"i64\", 1),\n  0xfe31: createSymbolObject(\"atomic.rmw16_u.and_u\", \"i64\", 1),\n  0xfe32: createSymbolObject(\"atomic.rmw32_u.and_u\", \"i64\", 1),\n  0xfe33: createSymbolObject(\"atomic.rmw.or\", \"i32\", 1),\n  0xfe34: createSymbolObject(\"atomic.rmw.or\", \"i64\", 1),\n  0xfe35: createSymbolObject(\"atomic.rmw8_u.or_u\", \"i32\", 1),\n  0xfe36: createSymbolObject(\"atomic.rmw16_u.or_u\", \"i32\", 1),\n  0xfe37: createSymbolObject(\"atomic.rmw8_u.or_u\", \"i64\", 1),\n  0xfe38: createSymbolObject(\"atomic.rmw16_u.or_u\", \"i64\", 1),\n  0xfe39: createSymbolObject(\"atomic.rmw32_u.or_u\", \"i64\", 1),\n  0xfe3a: createSymbolObject(\"atomic.rmw.xor\", \"i32\", 1),\n  0xfe3b: createSymbolObject(\"atomic.rmw.xor\", \"i64\", 1),\n  0xfe3c: createSymbolObject(\"atomic.rmw8_u.xor_u\", \"i32\", 1),\n  0xfe3d: createSymbolObject(\"atomic.rmw16_u.xor_u\", \"i32\", 1),\n  0xfe3e: createSymbolObject(\"atomic.rmw8_u.xor_u\", \"i64\", 1),\n  0xfe3f: createSymbolObject(\"atomic.rmw16_u.xor_u\", \"i64\", 1),\n  0xfe40: createSymbolObject(\"atomic.rmw32_u.xor_u\", \"i64\", 1),\n  0xfe41: createSymbolObject(\"atomic.rmw.xchg\", \"i32\", 1),\n  0xfe42: createSymbolObject(\"atomic.rmw.xchg\", \"i64\", 1),\n  0xfe43: createSymbolObject(\"atomic.rmw8_u.xchg_u\", \"i32\", 1),\n  0xfe44: createSymbolObject(\"atomic.rmw16_u.xchg_u\", \"i32\", 1),\n  0xfe45: createSymbolObject(\"atomic.rmw8_u.xchg_u\", \"i64\", 1),\n  0xfe46: createSymbolObject(\"atomic.rmw16_u.xchg_u\", \"i64\", 1),\n  0xfe47: createSymbolObject(\"atomic.rmw32_u.xchg_u\", \"i64\", 1),\n  0xfe48: createSymbolObject(\"atomic.rmw.cmpxchg\", \"i32\", 1),\n  0xfe49: createSymbolObject(\"atomic.rmw.cmpxchg\", \"i64\", 1),\n  0xfe4a: createSymbolObject(\"atomic.rmw8_u.cmpxchg_u\", \"i32\", 1),\n  0xfe4b: createSymbolObject(\"atomic.rmw16_u.cmpxchg_u\", \"i32\", 1),\n  0xfe4c: createSymbolObject(\"atomic.rmw8_u.cmpxchg_u\", \"i64\", 1),\n  0xfe4d: createSymbolObject(\"atomic.rmw16_u.cmpxchg_u\", \"i64\", 1),\n  0xfe4e: createSymbolObject(\"atomic.rmw32_u.cmpxchg_u\", \"i64\", 1)\n};\nvar symbolsByName = invertMap(symbolsByByte, function (obj) {\n  if (typeof obj.object === \"string\") {\n    return \"\".concat(obj.object, \".\").concat(obj.name);\n  }\n\n  return obj.name;\n});\nexport default {\n  symbolsByByte: symbolsByByte,\n  sections: sections,\n  magicModuleHeader: magicModuleHeader,\n  moduleVersion: moduleVersion,\n  types: types,\n  valtypes: valtypes,\n  exportTypes: exportTypes,\n  blockTypes: blockTypes,\n  tableTypes: tableTypes,\n  globalTypes: globalTypes,\n  importTypes: importTypes,\n  valtypesByString: valtypesByString,\n  globalTypesByString: globalTypesByString,\n  exportTypesByName: exportTypesByName,\n  symbolsByName: symbolsByName\n};\nexport { getSectionForNode } from \"./section\";","export function getSectionForNode(n) {\n  switch (n.type) {\n    case \"ModuleImport\":\n      return \"import\";\n\n    case \"CallInstruction\":\n    case \"CallIndirectInstruction\":\n    case \"Func\":\n    case \"Instr\":\n      return \"code\";\n\n    case \"ModuleExport\":\n      return \"export\";\n\n    case \"Start\":\n      return \"start\";\n\n    case \"TypeInstruction\":\n      return \"type\";\n\n    case \"IndexInFuncSection\":\n      return \"func\";\n\n    case \"Global\":\n      return \"global\";\n    // No section\n\n    default:\n      return;\n  }\n}","import { write, read } from \"@xtuc/ieee754\";\n/**\n * According to https://webassembly.github.io/spec/binary/values.html#binary-float\n * n = 32/8\n */\n\nexport var NUMBER_OF_BYTE_F32 = 4;\n/**\n * According to https://webassembly.github.io/spec/binary/values.html#binary-float\n * n = 64/8\n */\n\nexport var NUMBER_OF_BYTE_F64 = 8;\nexport var SINGLE_PRECISION_MANTISSA = 23;\nexport var DOUBLE_PRECISION_MANTISSA = 52;\nexport function encodeF32(v) {\n  var buffer = [];\n  write(buffer, v, 0, true, SINGLE_PRECISION_MANTISSA, NUMBER_OF_BYTE_F32);\n  return buffer;\n}\nexport function encodeF64(v) {\n  var buffer = [];\n  write(buffer, v, 0, true, DOUBLE_PRECISION_MANTISSA, NUMBER_OF_BYTE_F64);\n  return buffer;\n}\nexport function decodeF32(bytes) {\n  var buffer = new Uint8Array(bytes);\n  return read(buffer, 0, true, SINGLE_PRECISION_MANTISSA, NUMBER_OF_BYTE_F32);\n}\nexport function decodeF64(bytes) {\n  var buffer = new Uint8Array(bytes);\n  return read(buffer, 0, true, DOUBLE_PRECISION_MANTISSA, NUMBER_OF_BYTE_F64);\n}","// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nexport function extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\nexport function inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\nexport function getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\nexport function highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}","// Copyright 2012 The Obvious Corporation.\n\n/*\n * bufs: Buffer utilities.\n */\n\n/*\n * Module variables\n */\n\n/** Pool of buffers, where `bufPool[x].length === x`. */\nvar bufPool = [];\n/** Maximum length of kept temporary buffers. */\n\nvar TEMP_BUF_MAXIMUM_LENGTH = 20;\n/** Minimum exactly-representable 64-bit int. */\n\nvar MIN_EXACT_INT64 = -0x8000000000000000;\n/** Maximum exactly-representable 64-bit int. */\n\nvar MAX_EXACT_INT64 = 0x7ffffffffffffc00;\n/** Maximum exactly-representable 64-bit uint. */\n\nvar MAX_EXACT_UINT64 = 0xfffffffffffff800;\n/**\n * The int value consisting just of a 1 in bit #32 (that is, one more\n * than the maximum 32-bit unsigned value).\n */\n\nvar BIT_32 = 0x100000000;\n/**\n * The int value consisting just of a 1 in bit #64 (that is, one more\n * than the maximum 64-bit unsigned value).\n */\n\nvar BIT_64 = 0x10000000000000000;\n/*\n * Helper functions\n */\n\n/**\n * Masks off all but the lowest bit set of the given number.\n */\n\nfunction lowestBit(num) {\n  return num & -num;\n}\n/**\n * Gets whether trying to add the second number to the first is lossy\n * (inexact). The first number is meant to be an accumulated result.\n */\n\n\nfunction isLossyToAdd(accum, num) {\n  if (num === 0) {\n    return false;\n  }\n\n  var lowBit = lowestBit(num);\n  var added = accum + lowBit;\n\n  if (added === accum) {\n    return true;\n  }\n\n  if (added - lowBit !== accum) {\n    return true;\n  }\n\n  return false;\n}\n/*\n * Exported functions\n */\n\n/**\n * Allocates a buffer of the given length, which is initialized\n * with all zeroes. This returns a buffer from the pool if it is\n * available, or a freshly-allocated buffer if not.\n */\n\n\nexport function alloc(length) {\n  var result = bufPool[length];\n\n  if (result) {\n    bufPool[length] = undefined;\n  } else {\n    result = new Uint8Array(length);\n  }\n\n  result.fill(0);\n  return result;\n}\n/**\n * Releases a buffer back to the pool.\n */\n\nexport function free(buffer) {\n  var length = buffer.length;\n\n  if (length < TEMP_BUF_MAXIMUM_LENGTH) {\n    bufPool[length] = buffer;\n  }\n}\n/**\n * Resizes a buffer, returning a new buffer. Returns the argument if\n * the length wouldn't actually change. This function is only safe to\n * use if the given buffer was allocated within this module (since\n * otherwise the buffer might possibly be shared externally).\n */\n\nexport function resize(buffer, length) {\n  if (length === buffer.length) {\n    return buffer;\n  }\n\n  var newBuf = alloc(length);\n\n  for (var i = 0; i <= buffer.length; i++) {\n    newBuf[i] = buffer[i];\n  }\n\n  free(buffer);\n  return newBuf;\n}\n/**\n * Reads an arbitrary signed int from a buffer.\n */\n\nexport function readInt(buffer) {\n  var length = buffer.length;\n  var positive = buffer[length - 1] < 0x80;\n  var result = positive ? 0 : -1;\n  var lossy = false; // Note: We can't use bit manipulation here, since that stops\n  // working if the result won't fit in a 32-bit int.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (because the result has\n    // no more than 48 bits, and loss only happens with 54 or more).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i = length - 1; _i >= 0; _i--) {\n      var one = buffer[_i];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Reads an arbitrary unsigned int from a buffer.\n */\n\nexport function readUInt(buffer) {\n  var length = buffer.length;\n  var result = 0;\n  var lossy = false; // Note: See above in re bit manipulation.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (see above).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i2 = length - 1; _i2 >= 0; _i2--) {\n      var one = buffer[_i2];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Writes a little-endian 64-bit signed int into a buffer.\n */\n\nexport function writeInt64(value, buffer) {\n  if (value < MIN_EXACT_INT64 || value > MAX_EXACT_INT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  if (value < 0) {\n    value += BIT_64;\n  }\n\n  writeUInt64(value, buffer);\n}\n/**\n * Writes a little-endian 64-bit unsigned int into a buffer.\n */\n\nexport function writeUInt64(value, buffer) {\n  if (value < 0 || value > MAX_EXACT_UINT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  var lowWord = value % BIT_32;\n  var highWord = Math.floor(value / BIT_32);\n  buffer[0] = lowWord & 0xff;\n  buffer[1] = lowWord >> 8 & 0xff;\n  buffer[2] = lowWord >> 16 & 0xff;\n  buffer[3] = lowWord >> 24 & 0xff;\n  buffer[4] = highWord & 0xff;\n  buffer[5] = highWord >> 8 & 0xff;\n  buffer[6] = highWord >> 16 & 0xff;\n  buffer[7] = highWord >> 24 & 0xff;\n}","import leb from \"./leb\";\n/**\n * According to https://webassembly.github.io/spec/core/binary/values.html#binary-int\n * max = ceil(32/7)\n */\n\nexport var MAX_NUMBER_OF_BYTE_U32 = 5;\n/**\n * According to https://webassembly.github.io/spec/core/binary/values.html#binary-int\n * max = ceil(64/7)\n */\n\nexport var MAX_NUMBER_OF_BYTE_U64 = 10;\nexport function decodeInt64(encodedBuffer, index) {\n  return leb.decodeInt64(encodedBuffer, index);\n}\nexport function decodeUInt64(encodedBuffer, index) {\n  return leb.decodeUInt64(encodedBuffer, index);\n}\nexport function decodeInt32(encodedBuffer, index) {\n  return leb.decodeInt32(encodedBuffer, index);\n}\nexport function decodeUInt32(encodedBuffer, index) {\n  return leb.decodeUInt32(encodedBuffer, index);\n}\nexport function encodeU32(v) {\n  return leb.encodeUInt32(v);\n}\nexport function encodeI32(v) {\n  return leb.encodeInt32(v);\n}\nexport function encodeI64(v) {\n  return leb.encodeInt64(v);\n}","// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nimport Long from \"@xtuc/long\";\nimport * as bits from \"./bits\";\nimport * as bufs from \"./bufs\";\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\n\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = new Uint8Array(4);\n  buf[0] = num & 0xff;\n  buf[1] = num >> 8 & 0xff;\n  buf[2] = num >> 16 & 0xff;\n  buf[3] = num >> 24 & 0xff;\n  var result = encodeIntBuffer(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index); // sign-extend if necessary\n\n  var length = result.value.length;\n\n  if (result.value[length - 1] >> 7) {\n    result.value = bufs.resize(result.value, 8);\n    result.value.fill(255, length);\n  }\n\n  var value = Long.fromBytesLE(result.value, false);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = new Uint8Array(4);\n  buf[0] = num & 0xff;\n  buf[1] = num >> 8 & 0xff;\n  buf[2] = num >> 16 & 0xff;\n  buf[3] = num >> 24 & 0xff;\n  var result = encodeUIntBuffer(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, true);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nexport default {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};","function con(b) {\n  if ((b & 0xc0) === 0x80) {\n    return b & 0x3f;\n  } else {\n    throw new Error(\"invalid UTF-8 encoding\");\n  }\n}\n\nfunction code(min, n) {\n  if (n < min || 0xd800 <= n && n < 0xe000 || n >= 0x10000) {\n    throw new Error(\"invalid UTF-8 encoding\");\n  } else {\n    return n;\n  }\n}\n\nexport function decode(bytes) {\n  return _decode(bytes).map(function (x) {\n    return String.fromCharCode(x);\n  }).join(\"\");\n}\n\nfunction _decode(bytes) {\n  var result = [];\n\n  while (bytes.length > 0) {\n    var b1 = bytes[0];\n\n    if (b1 < 0x80) {\n      result.push(code(0x0, b1));\n      bytes = bytes.slice(1);\n      continue;\n    }\n\n    if (b1 < 0xc0) {\n      throw new Error(\"invalid UTF-8 encoding\");\n    }\n\n    var b2 = bytes[1];\n\n    if (b1 < 0xe0) {\n      result.push(code(0x80, ((b1 & 0x1f) << 6) + con(b2)));\n      bytes = bytes.slice(2);\n      continue;\n    }\n\n    var b3 = bytes[2];\n\n    if (b1 < 0xf0) {\n      result.push(code(0x800, ((b1 & 0x0f) << 12) + (con(b2) << 6) + con(b3)));\n      bytes = bytes.slice(3);\n      continue;\n    }\n\n    var b4 = bytes[3];\n\n    if (b1 < 0xf8) {\n      result.push(code(0x10000, (((b1 & 0x07) << 18) + con(b2) << 12) + (con(b3) << 6) + con(b4)));\n      bytes = bytes.slice(4);\n      continue;\n    }\n\n    throw new Error(\"invalid UTF-8 encoding\");\n  }\n\n  return result;\n}","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction con(n) {\n  return 0x80 | n & 0x3f;\n}\n\nexport function encode(str) {\n  var arr = str.split(\"\").map(function (x) {\n    return x.charCodeAt(0);\n  });\n  return _encode(arr);\n}\n\nfunction _encode(arr) {\n  if (arr.length === 0) {\n    return [];\n  }\n\n  var _arr = _toArray(arr),\n      n = _arr[0],\n      ns = _arr.slice(1);\n\n  if (n < 0) {\n    throw new Error(\"utf8\");\n  }\n\n  if (n < 0x80) {\n    return [n].concat(_toConsumableArray(_encode(ns)));\n  }\n\n  if (n < 0x800) {\n    return [0xc0 | n >>> 6, con(n)].concat(_toConsumableArray(_encode(ns)));\n  }\n\n  if (n < 0x10000) {\n    return [0xe0 | n >>> 12, con(n >>> 6), con(n)].concat(_toConsumableArray(_encode(ns)));\n  }\n\n  if (n < 0x110000) {\n    return [0xf0 | n >>> 18, con(n >>> 12), con(n >>> 6), con(n)].concat(_toConsumableArray(_encode(ns)));\n  }\n\n  throw new Error(\"utf8\");\n}","export { decode } from \"./decoder\";\nexport { encode } from \"./encoder\";","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decode = decode;\n\nvar _helperApiError = require(\"@webassemblyjs/helper-api-error\");\n\nvar ieee754 = _interopRequireWildcard(require(\"@webassemblyjs/ieee754\"));\n\nvar utf8 = _interopRequireWildcard(require(\"@webassemblyjs/utf8\"));\n\nvar t = _interopRequireWildcard(require(\"@webassemblyjs/ast\"));\n\nvar _leb = require(\"@webassemblyjs/leb128\");\n\nvar _helperWasmBytecode = _interopRequireDefault(require(\"@webassemblyjs/helper-wasm-bytecode\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\n\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n\n  function isEOF() {\n    return offset >= buf.length;\n  }\n\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n\n    return arr;\n  }\n\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n\n  function readU32() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U32);\n    var buffer = new Uint8Array(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = new Uint8Array(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = new Uint8Array(bytes);\n    return (0, _leb.decodeUInt32)(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n\n  function read32() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U32);\n    var buffer = new Uint8Array(bytes);\n    return (0, _leb.decodeInt32)(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n\n  function read64() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U64);\n    var buffer = new Uint8Array(bytes);\n    return (0, _leb.decodeInt64)(buffer);\n  }\n\n  function readU64() {\n    var bytes = readBytes(_leb.MAX_NUMBER_OF_BYTE_U64);\n    var buffer = new Uint8Array(bytes);\n    return (0, _leb.decodeUInt64)(buffer);\n  }\n\n  function readByte() {\n    return readBytes(1)[0];\n  }\n\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var header = readBytes(4);\n\n    if (byteArrayEq(_helperWasmBytecode[\"default\"].magicModuleHeader, header) === false) {\n      throw new _helperApiError.CompileError(\"magic header not detected\");\n    }\n\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var version = readBytes(4);\n\n    if (byteArrayEq(_helperWasmBytecode[\"default\"].moduleVersion, version) === false) {\n      throw new _helperApiError.CompileError(\"unknown binary version\");\n    }\n\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n\n    if (length === 0) {\n      return [];\n    }\n\n    var elements = [];\n\n    for (var i = 0; i < length; i++) {\n      var _byte = readByte();\n\n      eatBytes(1);\n      var value = cast(_byte);\n      dump([_byte], value);\n\n      if (typeof value === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n\n      elements.push(value);\n    }\n\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n\n    for (var i = 0; i < numberOfTypes; i++) {\n      var _startLoc = getPosition();\n\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n\n      if (type == _helperWasmBytecode[\"default\"].types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          var valtype = _helperWasmBytecode[\"default\"].valtypes[b];\n\n          if (valtype === undefined) {\n            throw new Error(\"unexpected value type \".concat(b));\n          }\n\n          return valtype;\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam(\n          /*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return _helperWasmBytecode[\"default\"].valtypes[b];\n        });\n        typeInstructionNodes.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);\n        }());\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n\n      var _startLoc2 = getPosition();\n      /**\n       * Module name\n       */\n\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = _helperWasmBytecode[\"default\"].importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n\n      if (typeof descrType === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n\n      var importDescr = void 0;\n\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new _helperApiError.CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"memory\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new _helperApiError.CompileError(\"Unsupported import of type: \" + descrType);\n      }\n\n      imports.push(function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);\n      }());\n    }\n\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n\n      if (typeof signature === \"undefined\") {\n        throw new _helperApiError.CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var _startLoc3 = getPosition();\n      /**\n       * Name\n       */\n\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n          signature = void 0;\n\n      if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n\n        if (typeof func === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown function (\".concat(index, \")\"));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n\n        if (typeof table === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown table \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Memory\") {\n        var memNode = state.memoriesInModule[index];\n\n        if (typeof memNode === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown memory \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (_helperWasmBytecode[\"default\"].exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n\n        if (typeof global === \"undefined\") {\n          throw new _helperApiError.CompileError(\"unknown global \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: _helperWasmBytecode[\"default\"].exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: _startLoc3\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var _startLoc4 = getPosition();\n\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = []; // Parse locals\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var _startLoc5 = getPosition();\n\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = _helperWasmBytecode[\"default\"].valtypes[valtypeByte];\n        var args = [];\n\n        for (var _i2 = 0; _i2 < localCount; _i2++) {\n          args.push(t.valtypeLiteral(type));\n        }\n\n        var localNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(\"local\", args), endLoc, _startLoc5);\n        }();\n\n        locals.push(localNode);\n        dump([valtypeByte], type);\n\n        if (typeof type === \"undefined\") {\n          throw new _helperApiError.CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      }\n\n      code.push.apply(code, locals); // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: _startLoc4,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n\n  function parseInstructionBlock(code) {\n    while (true) {\n      var _startLoc6 = getPosition();\n\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n\n      if (instructionByte === 0xfe) {\n        instructionByte = 0xfe00 + readByte();\n        eatBytes(1);\n      } // Table instructions\n      // https://webassembly.github.io/spec/core/binary/instructions.html#table-instructions\n\n\n      if (instructionByte === 0xfc) {\n        instructionByte = 0xfc00 + readByte();\n        eatBytes(1);\n      }\n\n      var instruction = _helperWasmBytecode[\"default\"].symbolsByByte[instructionByte];\n\n      if (typeof instruction === \"undefined\") {\n        throw new _helperApiError.CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n\n      if (instruction === \"illegal\") {\n        throw new Error(\"tried to decode an illegal bytecode: \".concat(toHex(instructionByte)));\n      }\n\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n\n      if (instruction.name === \"end\") {\n        var node = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);\n        }();\n\n        code.push(node);\n        break;\n      }\n\n      var args = [];\n      var namedArgs = void 0;\n\n      if (instruction.name === \"loop\") {\n        var _startLoc7 = getPosition();\n\n        var blocktype = parseBlockType();\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n\n        var loopNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);\n        }();\n\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _startLoc8 = getPosition();\n\n        var _blocktype = parseBlockType();\n\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n\n        var ifNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);\n        }();\n\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _startLoc9 = getPosition();\n\n        var _blocktype2 = parseBlockType();\n\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n\n        var blockNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);\n        }();\n\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n\n        var callNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);\n        }();\n\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var _startLoc10 = getPosition();\n\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new _helperApiError.CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n\n        if (flag !== 0) {\n          throw new _helperApiError.CompileError(\"zero flag expected\");\n        }\n\n        code.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(_callNode, endLoc, _startLoc10);\n        }());\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n          if (namedArgs === undefined) namedArgs = {};\n          namedArgs.offset = t.numberLiteralFromRaw(_offset2);\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n              low = _value2.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(_node);\n        }\n\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n              _low = _value3.low;\n          var _node2 = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node2);\n        }\n\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else if (instructionByte >= 0xfe00 && instructionByte <= 0xfeff) {\n        /**\n         * Atomic memory instructions\n         */\n        var align32 = readU32();\n        var _align = align32.value;\n        eatBytes(align32.nextIndex);\n        dump([_align], \"align\");\n\n        var _offsetu = readU32();\n\n        var _offset3 = _offsetu.value;\n        eatBytes(_offsetu.nextIndex);\n        dump([_offset3], \"offset\");\n      } else {\n        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i3);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          var _node3 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node3);\n        } else {\n          var _node4 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.instruction(instruction.name, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node4);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    var shared = limitType === 0x03;\n    dump([limitType], \"limit type\" + (shared ? \" (shared)\" : \"\"));\n    var min, max;\n\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n      var u32min = readU32();\n      min = parseInt(u32min.value);\n      eatBytes(u32min.nextIndex);\n      dump([min], \"min\");\n      var u32max = readU32();\n      max = parseInt(u32max.value);\n      eatBytes(u32max.nextIndex);\n      dump([max], \"max\");\n    }\n\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n\n    return t.limit(min, max, shared);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = _helperWasmBytecode[\"default\"].tableTypes[elementTypeByte];\n\n    if (typeof elementType === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Unknown element type in table: \" + toHex(elementTypeByte));\n    }\n\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = _helperWasmBytecode[\"default\"].valtypes[valtypeByte];\n    dump([valtypeByte], type);\n\n    if (typeof type === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = _helperWasmBytecode[\"default\"].globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n\n    if (typeof globalType === \"undefined\") {\n      throw new _helperApiError.CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n\n    return functionNames;\n  }\n\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n\n      for (var _i4 = 0; _i4 < numLocals; _i4++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n\n    return nameMetadata;\n  } // this is a custom section used for information about the producers\n  // https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md\n\n\n  function parseProducersSection() {\n    var metadata = t.producersSectionMetadata([]); // field_count\n\n    var sectionTypeByte = readVaruint32();\n    eatBytes(sectionTypeByte.nextIndex);\n    dump([sectionTypeByte.value], \"num of producers\");\n    var fields = {\n      language: [],\n      \"processed-by\": [],\n      sdk: []\n    }; // fields\n\n    for (var fieldI = 0; fieldI < sectionTypeByte.value; fieldI++) {\n      // field_name\n      var fieldName = readUTF8String();\n      eatBytes(fieldName.nextIndex); // field_value_count\n\n      var valueCount = readVaruint32();\n      eatBytes(valueCount.nextIndex); // field_values\n\n      for (var producerI = 0; producerI < valueCount.value; producerI++) {\n        var producerName = readUTF8String();\n        eatBytes(producerName.nextIndex);\n        var producerVersion = readUTF8String();\n        eatBytes(producerVersion.nextIndex);\n        fields[fieldName.value].push(t.producerMetadataVersionedName(producerName.value, producerVersion.value));\n      }\n\n      metadata.producers.push(fields[fieldName.value]);\n    }\n\n    return metadata;\n  }\n\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var _startLoc11 = getPosition();\n\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n\n      var node = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.global(globalType, init), endLoc, _startLoc11);\n      }();\n\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n\n    return globals;\n  }\n\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var _startLoc12 = getPosition();\n\n      var tableindexu32 = readU32();\n      var bitfield = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([bitfield], \"bitfield\");\n\n      if (bitfield === 0) {\n        // Parse instructions\n        var instr = [];\n        parseInstructionBlock(instr); // Parse ( vector function index ) *\n\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n        var indexValues = [];\n\n        for (var _i5 = 0; _i5 < indices; _i5++) {\n          var indexu32 = readU32();\n          var index = indexu32.value;\n          eatBytes(indexu32.nextIndex);\n          dump([index], \"index\");\n          indexValues.push(t.indexLiteral(index));\n        }\n\n        var elemNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.elem(t.indexLiteral(bitfield), instr, indexValues), endLoc, _startLoc12);\n        }();\n\n        elems.push(elemNode);\n      } else if (bitfield === 1) {\n        var elemKind = readByte();\n        eatBytes(1);\n\n        if (elemKind !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(elemKind)));\n        } // Parse ( vector function index ) *\n\n\n        var _indicesu = readU32();\n\n        var _indices = _indicesu.value;\n        eatBytes(_indicesu.nextIndex);\n        dump([_indices], \"num indices\");\n        var _indexValues = [];\n\n        for (var _i6 = 0; _i6 < _indices; _i6++) {\n          var _indexu2 = readU32();\n\n          var _index3 = _indexu2.value;\n          eatBytes(_indexu2.nextIndex);\n          dump([_index3], \"index\");\n\n          _indexValues.push(t.indexLiteral(_index3));\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 2) {\n        var u32 = readU32();\n        var tableidx = u32.value;\n        eatBytes(u32.nextIndex);\n        dump([tableidx], \"tableidx\"); // Parse instructions\n\n        var _instr3 = [];\n        parseInstructionBlock(_instr3);\n\n        var _elemKind = readByte();\n\n        eatBytes(1);\n\n        if (_elemKind !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(_elemKind)));\n        } // Parse ( vector function index ) *\n\n\n        var _indicesu2 = readU32();\n\n        var _indices2 = _indicesu2.value;\n        eatBytes(_indicesu2.nextIndex);\n        dump([_indices2], \"num indices\");\n        var _indexValues2 = [];\n\n        for (var _i7 = 0; _i7 < _indices2; _i7++) {\n          var _indexu3 = readU32();\n\n          var _index4 = _indexu3.value;\n          eatBytes(_indexu3.nextIndex);\n          dump([_index4], \"index\");\n\n          _indexValues2.push(t.indexLiteral(_index4));\n        }\n\n        var _elemNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.elem(t.indexLiteral(bitfield), _instr3, _indexValues2), endLoc, _startLoc12);\n        }();\n\n        elems.push(_elemNode);\n      } else if (bitfield === 3) {\n        var _elemKind2 = readByte();\n\n        eatBytes(1);\n\n        if (_elemKind2 !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(_elemKind2)));\n        } // Parse ( vector function index ) *\n\n\n        var countU32 = readU32();\n        var count = countU32.value;\n        eatBytes(countU32.nextIndex);\n        dump([count], \"count\");\n\n        for (var _i8 = 0; _i8 < count; _i8++) {\n          var _indexu4 = readU32();\n\n          var _index5 = _indexu4.value;\n          eatBytes(_indexu4.nextIndex);\n          dump([_index5], \"index\");\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 4) {\n        var expr = [];\n        parseInstructionBlock(expr);\n\n        var _countU = readU32();\n\n        var _count = _countU.value;\n        eatBytes(_countU.nextIndex);\n        dump([_count], \"count\");\n\n        for (var _i9 = 0; _i9 < _count; _i9++) {\n          var code = [];\n          parseInstructionBlock(code);\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 5) {\n        var reftype = readByte();\n        eatBytes(1);\n        dump([reftype], \"reftype\");\n\n        var _countU2 = readU32();\n\n        var _count2 = _countU2.value;\n        eatBytes(_countU2.nextIndex);\n        dump([_count2], \"count\");\n\n        for (var _i10 = 0; _i10 < _count2; _i10++) {\n          var _code = [];\n          parseInstructionBlock(_code);\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 7) {\n        var _reftype = readByte();\n\n        eatBytes(1);\n        dump([_reftype], \"reftype\");\n\n        var _countU3 = readU32();\n\n        var _count3 = _countU3.value;\n        eatBytes(_countU3.nextIndex);\n        dump([_count3], \"count\");\n\n        for (var _i11 = 0; _i11 < _count3; _i11++) {\n          var _code2 = [];\n          parseInstructionBlock(_code2);\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else {\n        throw new Error(\"unexpected Elem with bitfield \".concat(toHex(bitfield)));\n      }\n    }\n\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    return function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n    }();\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      var hasExtraInstrs = instrs.filter(function (i) {\n        return i.id !== \"end\";\n      }).length !== 1;\n\n      if (hasExtraInstrs) {\n        throw new _helperApiError.CompileError(\"data section offset must be a single instruction\");\n      }\n\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n\n    if (sectionId >= sectionIndex || sectionIndex === _helperWasmBytecode[\"default\"].sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== _helperWasmBytecode[\"default\"].sections.custom) throw new _helperApiError.CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n\n    var sectionSizeInBytesNode = function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), endLoc, startLoc);\n    }();\n\n    switch (sectionId) {\n      case _helperWasmBytecode[\"default\"].sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc13 = getPosition();\n\n          var _u = readU32();\n\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n          var metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endLoc, _startLoc13);\n          }());\n          var nodes = parseTypeSection(numberOfTypes);\n          return {\n            nodes: nodes,\n            metadata: metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc14 = getPosition();\n\n          var _u2 = readU32();\n\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          dump([numberOfTable], \"num tables\");\n\n          var _metadata = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTable), endLoc, _startLoc14);\n          }());\n\n          var _nodes = parseTableSection(numberOfTable);\n\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections[\"import\"]:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc15 = getPosition();\n\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          dump([numberOfImports], \"number of imports\");\n\n          var _metadata2 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfImports), endLoc, _startLoc15);\n          }());\n\n          var _nodes2 = parseImportSection(numberOfImports);\n\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc16 = getPosition();\n\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n\n          var _metadata3 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), endLoc, _startLoc16);\n          }());\n\n          parseFuncSection(numberOfFunctions);\n          var _nodes3 = [];\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections[\"export\"]:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc17 = getPosition();\n\n          var _u3 = readU32();\n\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n\n          var _metadata4 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfExport), endLoc, _startLoc17);\n          }());\n\n          parseExportSection(numberOfExport);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc18 = getPosition();\n\n          var _u4 = readU32();\n\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n\n          var _metadata5 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), endLoc, _startLoc18);\n          }());\n\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata6 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n\n          var _nodes6 = [parseStartSection()];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc19 = getPosition();\n\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n\n          var _metadata7 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfElements), endLoc, _startLoc19);\n          }());\n\n          var _nodes7 = parseElemSection(numberOfElements);\n\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc20 = getPosition();\n\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n\n          var _metadata8 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), endLoc, _startLoc20);\n          }());\n\n          var _nodes8 = parseGlobalSection(numberOfGlobals);\n\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc21 = getPosition();\n\n          var _numberOfElementsu = readU32();\n\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n\n          var _metadata9 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements), endLoc, _startLoc21);\n          }());\n\n          var _nodes9 = parseMemorySection(_numberOfElements);\n\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata10 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n\n          var _startLoc22 = getPosition();\n\n          var _numberOfElementsu2 = readU32();\n\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n\n          _metadata10.vectorOfSize = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), endLoc, _startLoc22);\n          }();\n\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes10 = parseDataSection(_numberOfElements2);\n\n            return {\n              nodes: _nodes10,\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n\n      case _helperWasmBytecode[\"default\"].sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata11 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n\n          if (sectionName.value === \"name\") {\n            var initialOffset = offset;\n\n            try {\n              _metadata11.push.apply(_metadata11, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (initialOffset + _remainingBytes2));\n            }\n          } else if (sectionName.value === \"producers\") {\n            var _initialOffset = offset;\n\n            try {\n              _metadata11.push(parseProducersSection());\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"producers\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (_initialOffset + _remainingBytes2));\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n\n          return {\n            nodes: [],\n            metadata: _metadata11,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n\n    if (opts.errorOnUnknownSection) {\n      throw new _helperApiError.CompileError(\"Unexpected section: \" + toHex(sectionId));\n    } else {\n      dumpSep(\"section \" + toHex(sectionId));\n      dump([sectionId], \"section code\");\n      dump([sectionSizeInBytes], \"section size\");\n      eatBytes(sectionSizeInBytes);\n      dumpSep(\"ignoring (\" + sectionSizeInBytes + \" bytes)\");\n      return {\n        nodes: [],\n        metadata: [],\n        nextSectionIndex: 0\n      };\n    }\n  }\n\n  function parseBlockType() {\n    var blocktypeByte = readByte();\n    var blocktype = _helperWasmBytecode[\"default\"].blockTypes[blocktypeByte];\n\n    if (typeof blocktype !== \"undefined\") {\n      eatBytes(1);\n      dump([blocktypeByte], \"blocktype\"); // value type\n\n      return blocktype;\n    } else {\n      // type index\n      var u32 = readU32();\n      eatBytes(u32.nextIndex);\n      var signature = state.typesInModule[u32.value];\n      console.log({\n        signature: signature\n      });\n      dump([u32.value], \"typeidx\");\n      return u32.value;\n    }\n  }\n\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: [],\n    producers: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n        nodes = _parseSection.nodes,\n        metadata = _parseSection.metadata,\n        nextSectionIndex = _parseSection.nextSectionIndex;\n\n    moduleFields.push.apply(moduleFields, _toConsumableArray(nodes));\n    var metadataArray = Array.isArray(metadata) ? metadata : [metadata];\n    metadataArray.forEach(function (metadataItem) {\n      // $FlowIgnore\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"ProducersSectionMetadata\") {\n        moduleMetadata.producers.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new _helperApiError.CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n\n      body = decodedElementInCodeSection.code;\n    }\n\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n\n    if (opts.ignoreCodeSection === false) {\n      var _startLoc23 = decodedElementInCodeSection.startLoc,\n          endLoc = decodedElementInCodeSection.endLoc,\n          bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, _startLoc23);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames, moduleMetadata.producers));\n  return t.program([module]);\n}","export function read(buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexport function write(buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","module.exports = Long;\n\n/**\n * wasm optimizations, to do native i64 multiplication and divide\n */\nvar wasm = null;\n\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n  ])), {}).exports;\n} catch (e) {\n  // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n    this.high = high | 0;\n\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n    this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n    if (unsigned) {\n        value >>>= 0;\n        if (cache = (0 <= value && value < 256)) {\n            cachedObj = UINT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n            UINT_CACHE[value] = obj;\n        return obj;\n    } else {\n        value |= 0;\n        if (cache = (-128 <= value && value < 128)) {\n            cachedObj = INT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n            INT_CACHE[value] = obj;\n        return obj;\n    }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n    if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n    if (unsigned) {\n        if (value < 0)\n            return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n            return MAX_UNSIGNED_VALUE;\n    } else {\n        if (value <= -TWO_PWR_63_DBL)\n            return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n            return MAX_VALUE;\n    }\n    if (value < 0)\n        return fromNumber(-value, unsigned).neg();\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n    if (str.length === 0)\n        throw Error('empty string');\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n    if (typeof unsigned === 'number') {\n        // For goog.math.long compatibility\n        radix = unsigned,\n        unsigned = false;\n    } else {\n        unsigned = !! unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n\n    var p;\n    if ((p = str.indexOf('-')) > 0)\n        throw Error('interior hyphen');\n    else if (p === 0) {\n        return fromString(str.substring(1), unsigned, radix).neg();\n    }\n\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n    var result = ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i),\n            value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n            var power = fromNumber(pow_dbl(radix, size));\n            result = result.mul(power).add(fromNumber(value));\n        } else {\n            result = result.mul(radixToPower);\n            result = result.add(fromNumber(value));\n        }\n    }\n    result.unsigned = unsigned;\n    return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n    if (typeof val === 'number')\n        return fromNumber(val, unsigned);\n    if (typeof val === 'string')\n        return fromString(val, unsigned);\n    // Throws for non-objects, converts non-instanceof Long:\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n    if (this.unsigned)\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    if (this.isZero())\n        return '0';\n    if (this.isNegative()) { // Unsigned Longs are never negative\n        if (this.eq(MIN_VALUE)) {\n            // We need to change the Long value before it can be negated, so we remove\n            // the bottom-most digit in this base and then recurse to do the rest.\n            var radixLong = fromNumber(radix),\n                div = this.div(radixLong),\n                rem1 = div.mul(radixLong).sub(this);\n            return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n            return '-' + this.neg().toString(radix);\n    }\n\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n        rem = this;\n    var result = '';\n    while (true) {\n        var remDiv = rem.div(radixToPower),\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n            digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero())\n            return digits + result;\n        else {\n            while (digits.length < 6)\n                digits = '0' + digits;\n            result = '' + digits + result;\n        }\n    }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) // Unsigned Longs are never negative\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n    for (var bit = 31; bit > 0; bit--)\n        if ((val & (1 << bit)) != 0)\n            break;\n    return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n        return false;\n    return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n    return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (this.eq(other))\n        return 0;\n    var thisNeg = this.isNegative(),\n        otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg)\n        return -1;\n    if (!thisNeg && otherNeg)\n        return 1;\n    // At this point the sign bits are the same\n    if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n    // Both are positive if at least one is unsigned\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE))\n        return MIN_VALUE;\n    return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n    if (!isLong(addend))\n        addend = fromValue(addend);\n\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero())\n        return ZERO;\n    if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n\n    // use wasm support if present\n    if (wasm) {\n        var low = wasm[\"mul\"](this.low,\n                              this.high,\n                              multiplier.low,\n                              multiplier.high);\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n\n    if (multiplier.isZero())\n        return ZERO;\n    if (this.eq(MIN_VALUE))\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE))\n        return this.isOdd() ? MIN_VALUE : ZERO;\n\n    if (this.isNegative()) {\n        if (multiplier.isNegative())\n            return this.neg().mul(multiplier.neg());\n        else\n            return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n\n    // If both longs are small, use float multiplication\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    if (divisor.isZero())\n        throw Error('division by zero');\n\n    // use wasm support if present\n    if (wasm) {\n        // guard against signed division overflow: the largest\n        // negative number / -1 would be 1 larger than the largest\n        // positive number, due to two's complement.\n        if (!this.unsigned &&\n            this.high === -0x80000000 &&\n            divisor.low === -1 && divisor.high === -1) {\n            // be consistent with non-wasm code path\n            return this;\n        }\n        var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n            this.low,\n            this.high,\n            divisor.low,\n            divisor.high\n        );\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n\n    if (this.isZero())\n        return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n    if (!this.unsigned) {\n        // This section is only relevant for signed longs and is derived from the\n        // closure library as a whole.\n        if (this.eq(MIN_VALUE)) {\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n            else if (divisor.eq(MIN_VALUE))\n                return ONE;\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = this.shr(1);\n                approx = halfThis.div(divisor).shl(1);\n                if (approx.eq(ZERO)) {\n                    return divisor.isNegative() ? ONE : NEG_ONE;\n                } else {\n                    rem = this.sub(divisor.mul(approx));\n                    res = approx.add(rem.div(divisor));\n                    return res;\n                }\n            }\n        } else if (divisor.eq(MIN_VALUE))\n            return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n            if (divisor.isNegative())\n                return this.neg().div(divisor.neg());\n            return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n            return this.div(divisor.neg()).neg();\n        res = ZERO;\n    } else {\n        // The algorithm below has not been made for unsigned longs. It's therefore\n        // required to take special care of the MSB prior to running it.\n        if (!divisor.unsigned)\n            divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n            return UZERO;\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n        res = UZERO;\n    }\n\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    rem = this;\n    while (rem.gte(divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n        // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\n\n        // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx),\n            approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n            approx -= delta;\n            approxRes = fromNumber(approx, this.unsigned);\n            approxRem = approxRes.mul(divisor);\n        }\n\n        // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n        if (approxRes.isZero())\n            approxRes = ONE;\n\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n    }\n    return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n\n    // use wasm support if present\n    if (wasm) {\n        var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n            this.low,\n            this.high,\n            divisor.low,\n            divisor.high\n        );\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n\n    return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    else if (numBits < 32)\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n    else\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    else if (numBits < 32)\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n    else\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);\n    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n    return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned)\n        return this;\n    return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned)\n        return this;\n    return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high,\n        lo = this.low;\n    return [\n        lo        & 0xff,\n        lo >>>  8 & 0xff,\n        lo >>> 16 & 0xff,\n        lo >>> 24       ,\n        hi        & 0xff,\n        hi >>>  8 & 0xff,\n        hi >>> 16 & 0xff,\n        hi >>> 24\n    ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high,\n        lo = this.low;\n    return [\n        hi >>> 24       ,\n        hi >>> 16 & 0xff,\n        hi >>>  8 & 0xff,\n        hi        & 0xff,\n        lo >>> 24       ,\n        lo >>> 16 & 0xff,\n        lo >>>  8 & 0xff,\n        lo        & 0xff\n    ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(\n        bytes[0]       |\n        bytes[1] <<  8 |\n        bytes[2] << 16 |\n        bytes[3] << 24,\n        bytes[4]       |\n        bytes[5] <<  8 |\n        bytes[6] << 16 |\n        bytes[7] << 24,\n        unsigned\n    );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(\n        bytes[4] << 24 |\n        bytes[5] << 16 |\n        bytes[6] <<  8 |\n        bytes[7],\n        bytes[0] << 24 |\n        bytes[1] << 16 |\n        bytes[2] <<  8 |\n        bytes[3],\n        unsigned\n    );\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\r\nimport { index } from './../../node_modules/@webassemblyjs/wasm-parser/lib/decoder';\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n\r\n    const tabs = document.querySelectorAll('.tabheader__item');\r\n    const tabsContent = document.querySelectorAll('.tabcontent');\r\n    const tabsParent = document.querySelector('.tabheader__items');\r\n\r\n    console.log('tabs:', tabs);\r\n    console.log('tabsContent:', tabsContent);\r\n\r\n\r\n\r\n\r\n\r\n    function hideTabContent() {\r\n        tabsContent.forEach(item => {\r\n            item.style.display = 'none';\r\n        });\r\n        tabs.forEach(item => {\r\n            item.classList.remove('tabheader__item_active');\r\n        })\r\n    }\r\n\r\n    function showTabContent(i = 0) {\r\n        tabsContent[i].style.display = 'block';\r\n\r\n        tabs[i].classList.add('tabheader__item_active');\r\n    }\r\n\r\n    \r\n    \r\n\r\n    tabsParent.addEventListener('click', (e) => {\r\n        const target = e.target;\r\n        if (target && target.classList.contains('tabheader__item')) {\r\n            tabs.forEach((tab, index) => {\r\n                if (target === tab) {\r\n                    hideTabContent();\r\n                    showTabContent(index);\r\n                }\r\n                \r\n            })\r\n        }\r\n\r\n    })\r\n\r\n    hideTabContent();\r\n\r\n    showTabContent();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n})"],"names":["index","document","addEventListener","tabs","querySelectorAll","tabsContent","tabsParent","querySelector","console","log","hideTabContent","forEach","item","style","display","classList","remove","showTabContent","i","add","e","target","contains","tab"],"sourceRoot":""}